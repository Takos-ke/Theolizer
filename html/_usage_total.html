<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theolizer: 使用方法（全体）</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Theolizer
   &#160;<span id="projectnumber">Version.0.4.1-Prerelease.</span>
   </div>
   <div id="projectbrief">serializer for C++ / Do you want to update your classes easily ?</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_usage_total.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">使用方法（全体） </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ここでは、Theolizerの使い方を説明します。</p>
<p>TheolizerはAPIの機能テストをできるだけ自動化してます。<br />
 そして、APIの機能テストは詳細仕様を規定することでもあります。複雑なプログラムでは文書として読み取ることは困難ですが、単純なプログラムであれば、文書としての機能を果たせるのではないかと考えています。</p>
<p>そこで、各機能についてそれをテストするための多数のテスト群の内、代表的なものを使って説明し、詳細テストの関連部分のソースも提示します。できるだけ読み取るのに苦労しない形式でプログラムを記述し、詳細仕様書として有用であることを目指します。</p>
<p>まず、1～3節で全体的な説明を行い、4節以降で各機能について説明します。</p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Naming"></a>
1.名前の付け方</h1>
<h6></h6>
<p>TheolizerのAPIは名前空間に入れています。また、マクロは決まったプリフィクスを付けています。 少し意味を持たせていますので説明します。</p>
<h2><a class="anchor" id="Namespace"></a>
1-1.名前空間</h2>
<p>ほぼ全てのシンボルを <b>theolizer</b> 名前空間へ入れています。<br />
 一部、入れると実装が難しいものについては、シンボルに <b>Theolizer</b> を含みます。<br />
 これにより既存のコードと被ることはまずない筈です。</p>
<p>次に、内部的に使用するシンボルは <b>internal</b> 名前空間へ入れています。<br />
 これらのシンボルが付けられたクラスや関数等は、Theolizerのアップデート時、上位互換性を考慮しませんので使用しないようお願いします。</p>
<h2><a class="anchor" id="MacroName"></a>
1-2.マクロ名</h2>
<p>全てのマクロは <b>THEOLIZER_</b> で始めています。<br />
 これにより既存のコードと被ることはまずない筈です。</p>
<p>次に、内部的に使用するマクロは、 <b>THEOLIZER_INTERNAL_</b> で始めています。<br />
 また、Theolizerが自動生成するマクロを、 <b>THEOLIZER_GENERATED_</b> で始めています。<br />
 これらのマクロは、Theolizerのアップデート時、上位互換性を考慮しませんので使用しないようお願いします。 <br />
 </p><h6></h6>
<h1><a class="anchor" id="BasicUsage"></a>
2.基本的な使い方</h1>
<h6></h6>
<p>Theolizerをインストールした後、あなたのデータをTheolizerでシリアライズするために、あなたのプログラムを下記の順序を守るようにして下さい。</p>
<ol type="1">
<li>Theolizerヘッダをインクルード</li>
<li>シリアライズするクラスとenum型の定義</li>
<li>Theolizerの自動生成ファイルをインクルード</li>
<li>シリアライズ処理</li>
</ol>
<h2><a class="anchor" id="TheolizerHeader"></a>
2-1.Theolizerヘッダをインクルード</h2>
<p>一部例外(*1)はありますが原則として、<b>シリアライズするクラスとenum型の定義</b> 前にシリアライザのヘッダをインクルードして下さい。<br />
</p>
<p><b>Json形式シリアライザ・ヘッダのインクルードと型定義の例：(source/samples/example/example.h）</b></p>
 <div class="fragment"><div class="line"><span class="comment">// ***************************************************************************</span></div><div class="line"><span class="comment">//      インクルード</span></div><div class="line"><span class="comment">// ***************************************************************************</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializer__json_8h.html">theolizer/serializer_json.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// ***************************************************************************</span></div><div class="line"><span class="comment">//      型定義</span></div><div class="line"><span class="comment">// ***************************************************************************</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> EnumType</div><div class="line">{</div><div class="line">    <a class="code" href="namespacetheolizer.html#ab58d637248b6f2072509a837b6de1e7ba6adf97f83acf6453d4a6a4b1070f3754">None</a>,</div><div class="line">    EnumA,</div><div class="line">    EnumB,</div><div class="line">    EnumC</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>StructType</div><div class="line">{</div><div class="line">    EnumType    mEnum;</div><div class="line">    <span class="keywordtype">int</span>         mInt;</div><div class="line">    std::string mString;</div><div class="line">    StructType() : mEnum(<a class="code" href="namespacetheolizer.html#ab58d637248b6f2072509a837b6de1e7ba6adf97f83acf6453d4a6a4b1070f3754">None</a>), mInt(0), mString(<span class="stringliteral">&quot;&quot;</span>) { }</div><div class="line">};</div></div><!-- fragment --></p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*1) 例外：<b>非侵入型</b>(<a class="el" href="_specification.html#Basic12">1-2.シリアライズ可能な型についての補足事項</a>)のクラスやenum型については、<b>シリアライザのヘッダをインクルード</b>する前でも定義できます。<br />
 </div><p>現在、サポートしているシリアライザはJson形式、独自Binary形式、メモリ内専用のFast形式の3種類です。 それぞれ、下記ヘッダをインクールドして下さい。</p>
<table class="doxtable">
<tr>
<th>形式</th><th>インクルードするヘッダ</th><th>注意事項  </th></tr>
<tr>
<td>Json形式</td><td>&lt;<a class="el" href="serializer__json_8h.html" title="Jsonシリアライザ ">theolizer/serializer_json.h</a>&gt;</td><td>fstreamはテキスト・モードでオープンする </td></tr>
<tr>
<td>独自Binary形式</td><td>&lt;<a class="el" href="serializer__binary_8h_source.html">theolizer/serializer_binary.h</a>&gt;</td><td>fstreamは<b>バイナリ・モード(std::ios_base::binary)</b>でオープンする </td></tr>
<tr>
<td>メモリ内専用Fast形式</td><td>上記のどちから、もしくは、&lt;<a class="el" href="serializer_8h_source.html">theolizer/serializer.h</a>&gt;</td><td>fstreamは<b>バイナリ・モード(std::ios_base::binary)</b>でオープンする </td></tr>
</table>
<p><br />
 </p><div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <a class="anchor" id="バイナリ・モード"></a><b>バイナリ形式における注意事項：</b><br />
 バイナリ形式のシリアライザをfstreamで用いる時は、必ずバイナリ・モード（std::ios_base::binary）でfstreamをオープンして下さい。<br />
 fstreamがテキスト・モードでオープンされている場合、ファイル・ストリームへ数値26(0x1A)が出力されると、これはEOFコードなので回復時にEOFエラーになります。また、Windowsで数値10(0x0A)が出力されるとCR LFへ展開されてしまい、適切に回復できません。<br />
 このような事態をさけるため、Theolizer側でエラーにしたいのですが、iostreamではそのオープン・モードを確認できないためチェックが困難なのです。<br />
 </div><p> <br />
</p>
<h2><a class="anchor" id="DefineClassEnum"></a>
2-2.シリアライズするクラスとenum型の定義</h2>
<p><b>シリアライズするクラスとenum型の定義</b>後に、<b>Theolizerの自動生成ファイルをインスクルード</b> します。この順序に例外はありません。<br />
</p>
<p>なお、シリアライズ対象の型を含まないヘッダ・ファイルは、Theolizerに関する順序制限はありません。</p>
<p><b>クラスとenum型定義例：(source/samples/example/example.h）</b></p>
<h2><a class="anchor" id="IncludeAutoGeneratedFile"></a>
2-3.Theolizerの自動生成ファイルをインクルード</h2>
<p><a class="el" href="_abstract.html#Mechanism">4.Theolizerの仕組み</a> で説明したようにTheolizerはシリアライズに必要なソース・コードを自動生成します。<br />
 このファイルはコンパイル単位（通常は.cppファイル）毎に生成され、当該.cppファイルと同じフォルダへ自動的に生成されます。<br />
 Theolizerは、バージョンを上げた時に古いクラス定義やenum型定義をここに残します。これにより古いシリアライズ・データを回復できます。<br />
 そこで、このファイルをお使いのバージョン管理システム（gitやsvn等）へ登録することをお勧めします。</p>
<p>自動生成するファイルのファイル名は、そのコンパイル単位のファイル名に".theolzier.hpp"を繋げたものです。<br />
 例えば、<b>example.cpp</b> の場合は、<b>example.cpp.theolizer.hpp</b> となります。</p>
<p><b>例：(source/samples/example/example.cpp）</b></p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;example.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;example.cpp.theolizer.hpp&quot;</span>                <span class="comment">// Theolizer自動生成先</span></div></div><!-- fragment --></p>
<h2><a class="anchor" id="SerializingProcess"></a>
2-4.シリアライズ処理</h2>
<p>シリアライズは下記の３つで行います。</p><ul>
<li>シリアライザ・インスタンスの生成</li>
<li>シリアライズ処理要求（シリアライズするインスタンスを指定する）</li>
<li>シリアライザ・インスタンスの破棄</li>
</ul>
<h3><a class="anchor" id="ConstructSerializer"></a>
2-4-1.シリアライザ・インスタンスの生成</h3>
<p>その際、シリアライズ先のデータ・ストリームを指定します。ファイル・ストリームや<a href="http://localhost/theolizer/tcp_ip_sample/">TCP/IPストリーム</a>を指定して下さい。<br />
 保存や送信時はstd::ostreamを、回復や受信時はstd::istreamを与えて下さい。</p>
<ul>
<li><b>保存（送信用）シリアライザ</b> <br />
 theolizer::JsonOSerialzier<br />
 theolizer::BinaryOSerialzier<br />
 theolizer::FastOSerialzier<br />
</li>
<li><b>回復（受信用）シリアライザ（デシリアライザ）</b> <br />
 theolizer::JsonISerialzier<br />
 <a class="el" href="classtheolizer_1_1_binary_i_serializer.html" title="回復用BinarySerializer ">theolizer::BinaryISerializer</a><br />
 theolizer::FastISerialzier<br />
</li>
</ul>
<h3><a class="anchor" id="Request"></a>
2-4-2.シリアライズ処理要求</h3>
<p>下記マクロでシリアライズします。保存用シリアライザを指定すると保存、回復用シリアライザを指定すると回復動作となります。<br />
 これはいつくでも記述して良いです。</p>
<p><b>THEOLIZER_PROCESS(dSerializer, dInstance)</b></p><ul>
<li>dSerializer : シリアライザのインスタンスを指定します。<br />
</li>
<li>dInstance : 保存するインスタンスを指定します。<br />
</li>
</ul>
<p>dInstanceを保存／回復します。<br />
 ポインタ型を指定した場合は、アドレス回復のためにポイント先のオブジェクト追跡を行います。<br />
</p>
<p>他にTHEOLIZER_PROCESS_POINTEE()とTHEOLIZER_PROCESS_OWNER()がありますが、これらについては「<a class="el" href="_object_tracking.html">オブジェクト追跡について</a> 」で説明します。</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> このようにシリアライザを問わず、全て同じマクロでシリアライズ処理できます。<br />
 xmlも将来的にサポートする予定ですが、その際も同じマクロで対応できる筈です。<br />
 （マクロなので、#演算によりインスタンス名をC言語文字列として取り出して用います。） </div><h3><a class="anchor" id="DestructSerializer"></a>
2-4-3.シリアライザ・インスタンスの破棄</h3>
<p>最後にシリアライザ・インスタンスを破棄することでシリアライズ処理を完了します。<br />
 生成時に例外発生を禁止していた場合に、エラー状態をリセットしないまま破棄すると、プロセスをアボートします。これはエラー状態の見逃しを回避するための仕様です。<br />
 例外発生を禁止している場合は、破棄する前には必ずエラー情報をチェクした上で、エラー状態をリセットして下さい。<br />
 具体的手順は<a class="el" href="_error_report.html">エラー処理方法</a> にて説明します。</p>
<p><b>ファイルへの保存例：(source/samples/example/example.cpp）</b></p>
 <div class="fragment"><div class="line">    {</div><div class="line">        <span class="comment">// データを生成する</span></div><div class="line">        StructType aStructType;</div><div class="line">        aStructType.mEnum   = EnumB;</div><div class="line">        aStructType.mInt    = 1001;</div><div class="line">        aStructType.mString = u8<span class="stringliteral">&quot;ＵＴＦ－８　ｓｔｒｉｎｇ&quot;</span>;</div><div class="line"></div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;example.json&quot;</span>);    <span class="comment">// 保存先のファイルをオープンする</span></div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> js(aStream);   <span class="comment">// シリアライザを用意する</span></div><div class="line">        THEOLIZER_PROCESS(js, aStructType);         <span class="comment">// example.jsonファイルへ保存する</span></div><div class="line">    }</div></div><!-- fragment --></p>
<p><b>ファイルからの回復例：(source/samples/example/example.cpp）</b></p>
<p><div class="fragment"><div class="line">    {</div><div class="line">        StructType aStructType;                     <span class="comment">// データ領域を獲得する</span></div><div class="line">        std::ifstream   aStream(<span class="stringliteral">&quot;example.json&quot;</span>);    <span class="comment">// 回復元のファイルをオープンする</span></div><div class="line">        <a class="code" href="classtheolizer_1_1_json_i_serializer.html">theolizer::JsonISerializer&lt;&gt;</a> js(aStream);   <span class="comment">// シリアライザを用意する</span></div><div class="line">        THEOLIZER_PROCESS(js, aStructType);         <span class="comment">// example.jsonファイルから回復する</span></div><div class="line"></div><div class="line">        <span class="comment">// 回復結果を表示する</span></div><div class="line">        std::cout &lt;&lt;<a class="code" href="namespacetheolizer.html#ae08153a6de69bbdbf4807073d2d5af01">theolizer::print</a></div><div class="line">                    (</div><div class="line">                        u8<span class="stringliteral">&quot;mEnum=%d mInt=%d mString=[%s]\n&quot;</span>,</div><div class="line">                        aStructType.mEnum,</div><div class="line">                        aStructType.mInt,</div><div class="line">                        aStructType.mString</div><div class="line">                    );</div><div class="line">    }</div></div><!-- fragment --></p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Serializers"></a>
3.各シリアライザの説明</h1>
<h6></h6>
<p>現在、サポートしているシリアライザはJson形式、独自Binary形式、メモリ内専用のFast形式の3種類です。<br />
 ここではそれぞれの使い方を説明します。</p>
<p><br />
</p>
<h2><a class="anchor" id="Serializer"></a>
3-1.共通事項</h2>
<p>全てのシリアライザについて共通な事項について説明します。</p>
<h3><a class="anchor" id="CheckMode"></a>
3-1-1.型チェック・モード</h3>
<p>Theolizerのシリアライザは回復時に型が一致していることをチェックできます。<br />
 その方法としてシリライズ・データ内に「型名を保存する方法」と「型に割り当てたインデックス番号（TypeIndex）を保存する方法」の２種類を用意しています。</p>
<p><a class="el" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e" title="型チェック・モード ">theolizer::CheckMode</a> </p><table class="doxtable">
<tr>
<th>列挙値</th><th>意味  </th></tr>
<tr>
<td>NoTypeCheck</td><td>型チェック無し </td></tr>
<tr>
<td>TypeCheck</td><td>型名による型チェック </td></tr>
<tr>
<td>TypeCheckByIndex</td><td>TypeIndexによる型チェック </td></tr>
</table>
<p>NoTypeCheckは型情報をシリライズ・データに含みませんのでデータ量が少ない場合の効率は良いです。しかし、メンバ名をヘッダではなくデータ側に含むためデータ量が多くなると効率は悪化します。<br />
 TypeCheckはテキスト型の場合、データを目視確認し易いです。データ量が少ない時の効率はNoTypeCheckの次に良いです。<br />
 TypeCheckByIndexはデータ量が多い時は３種のCheckModeの中で最大の効率を発揮します。</p>
<p>型情報等の管理データを下記のように記録します。</p><ul>
<li><b>シリアライズ・データのヘッダ部</b><br />
 <b>NoTypeCheck：</b>型情報を記録しません。<br />
 <b>TypeCheck：</b>クラスについて、各メンバのメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）と型名を記録します。<br />
 <b>TypeCheckByIndex：</b>全ての型について、TypeIndexに対応する型名を記録します。 更にクラスについては、各メンバのメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）とTypeIndexを記録します。<br />
 <br />
</li>
<li><b>シリアライズ・データの各データ部</b><br />
 <b>NoTypeCheck：</b>クラスについて、各メンバのデータとメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）をセットで記録します。<br />
 <b>TypeCheck：</b>THEOLIZER_PROCESS()マクロで指定したデータと共にその型名を記録します。<br />
 <b>TypeCheckByIndex：</b>THEOLIZER_PROCESS()マクロで指定したデータと共にそのTypeIndexを記録します。<br />
</li>
</ul>
<p>回復時に回復先の変数の型と上記の情報と照らし合わせることで型チェックを行います。<br />
</p>
<h3><a class="anchor" id="DerivedMembers"></a>
3-1-2.派生メンバ</h3>
<p>各シリアライザが継承しているメンバの内、公開しているものは下記です。</p>
<table class="doxtable">
<tr>
<th>メンバ名</th><th>意味  </th></tr>
<tr>
<td>static const bool kIsSaver ;</td><td>保存用はtrue／回復用はfalse </td></tr>
<tr>
<td>static const bool kIsFastSerialzier ;</td><td>FastSerializerのみtrue </td></tr>
<tr>
<td>void clearTracking() ;</td><td>オブジェクト追跡の区切り（<a class="el" href="_object_tracking.html">オブジェクト追跡について</a> 参照） </td></tr>
<tr>
<td><a class="el" href="classtheolizer_1_1_error_info.html">theolizer::ErrorInfo</a> const&amp; getError() ;</td><td>エラー情報返却 </td></tr>
<tr>
<td>void resetError() ;</td><td>エラー状態解除 </td></tr>
<tr>
<td>bool isTerminated() const ;</td><td>処理中のクラスの読み出しが終了(mTerminated)していたらtrueを返却します。<br />
非侵入型手動クラスで回復処理を実装する際に使用します。 </td></tr>
</table>
<p><br />
</p>
<h2><a class="anchor" id="JsonSerializer"></a>
3-2.Json形式（JsonSerializer）</h2>
<p>Json形式でシリアライズする場合は、<b><a class="el" href="serializer__json_8h.html" title="Jsonシリアライザ ">theolizer/serializer_json.h</a></b>をインクルードして下さい。</p>
<h3><a class="anchor" id="JsonOSerialzier"></a>
3-2-1.保存用JsonSerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_json_o_serializer.html#a8e750bcb8c34016ed4fe755cca9ffd41">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">JsonOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">unsigned</span> iGlobalVersionNo=kLastGlobalVersionNo,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode=CheckMode::NoTypeCheck,</div><div class="line">    <span class="keywordtype">bool</span> iNoPrettyPrint=<span class="keyword">false</span>,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><p><a class="el" href="classtheolizer_1_1_json_o_serializer.html#a974a676a08fd3076e5b23505d04f38e7">GlobalVersionNo以外のオプションを指定するコンストラクタ </a></p>
<div class="fragment"><div class="line">JsonOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode,</div><div class="line">    <span class="keywordtype">bool</span> iNoPrettyPrint=<span class="keyword">false</span>,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamはテキスト・モードでオープンして下さい） </td></tr>
<tr>
<td>iGlobalVersionNo</td><td>保存するグローバル・バージョン番号(省略時は最新版) </td></tr>
<tr>
<td>iCheckMode</td><td>型チェック・モード（省略時はNoTypeCheck) </td></tr>
<tr>
<td>iNoPrettyPrint</td><td>整形出力しない時true（省略時はfalse) </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>専用継承関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>void setCharIsMultiByte(bool iCharIsMultiByte);</b><br />
 iCharIsMultiByte=trueの時、std::stringをWindowsマルチ・バイト文字コードとして取り扱います。<br />
 コンストラクト直後はiCharIsMultiByte=falseです。<br />
 Windowsのみ機能します。それ以外のOSではUTF-8のままです。 </div><h3><a class="anchor" id="JsonISerialzier"></a>
3-2-2.回復用JsonSerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_json_i_serializer.html#ad42cf979d39c85e055e9fcad774f8185">コンストラクタ </a></p>
<div class="fragment"><div class="line">JsonISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamならテキスト・モードでオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>専用継承関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>void setCharIsMultiByte(bool iCharIsMultiByte);</b><br />
 iCharIsMultiByte=trueの時、std::stringをWindowsマルチ・バイト文字コードとして取り扱います。<br />
 コンストラクト直後はiCharIsMultiByte=falseです。<br />
 Windowsのみ機能します。それ以外のOSではUTF-8のままです。 </div><p><br />
</p>
<h2><a class="anchor" id="BinarySerializer"></a>
3-3.独自Binary形式（BinarySerializer）</h2>
<p>独自Binary形式でシリアライズする場合は、<b><a class="el" href="serializer__binary_8h_source.html">theolizer/serializer_binary.h</a></b>をインクルードして下さい。<br />
 また、ファイル・ストリームは必ず<a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> でオープンして下さい。</p>
<p>Big Endianでエンコードします。Little Endianの処理系の場合Big Endianとの間で自動変換します。<br />
 整数型は値を表現するために十分なバイト数で保存します。例えば、long long型でも値が10ならタグと値で合わせて2バイトで保存します。<br />
 浮動小数点型はIEEE754フォーマットのみサポートします。バイト単位でEndian変換します。<br />
 long doubleは「radix==2、digits==64、max_exponent==16384」の80ビット拡張精度形式である処理系（gcc）とbinary64である処理系(msvc)に対応しています。<br />
 文字コードの変換は行いません。Endianのみ変換してシリアライズします。<br />
</p>
<h3><a class="anchor" id="BinaryOSerialzier"></a>
3-3-1.保存用BinarySerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_binary_o_serializer.html#ae71e52ea12cc23e344f655880ec446e7">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">unsigned</span> iGlobalVersionNo=kLastGlobalVersionNo,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode=CheckMode::NoTypeCheck,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><p><a class="el" href="classtheolizer_1_1_binary_o_serializer.html#a5d883db832dda088714169b268bc09b5">GlobalVersionNo以外のオプションを指定するコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamは<b><a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> </b>でオープンして下さい） </td></tr>
<tr>
<td>iGlobalVersionNo</td><td>保存するグローバル・バージョン番号(省略時は最新版) </td></tr>
<tr>
<td>iCheckMode</td><td>型チェック・モード（省略時はNoTypeCheck) </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h3><a class="anchor" id="BinaryISerializer"></a>
3-3-2.回復用BinarySerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_binary_i_serializer.html#a06d109cddbadd6d9b2542eaedc1a5f3c">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamは<b><a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> </b>でオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<p><br />
</p>
<h2><a class="anchor" id="FastSerializer"></a>
3-4.メモリ内専用のFast形式（FastSerializer）</h2>
<p>FastSerializerの使用目的はデータ構造のプログラム内コピーです。外部プログラムとのデータ交換は想定していません<br />
</p>
<p>Theolizerが内部的に使用していますので、他のシリアライザのヘッダをインクルードすれば改めてヘッダをインクルードする必要はありません。<br />
 もし、他のシリアライザを使用しない時は、theolizer/serializer.hをインクルードして下さい。<br />
 また、ストリームはstd::stringstreamを用いることを想定していますが、もしも、ファイル・ストリームを与える場合は必ず<a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> でオープンして下さい。<br />
 FastSerializerはデータ変換しません。バージョンの相違にも対応していません。<br />
 オーナー指定ポインタでない通常のポインタは、ポイント先をシリアライズしていない場合はシャロー・コピーになります。（ポインタ値を単純にコピーする。）<br />
</p>
<h3><a class="anchor" id="FastOSerializer"></a>
3-4-1.保存用FastSerializer</h3>
<p><a class="el" href="classtheolizer_1_1_fast_o_serializer.html#adac5dc58f348dcab99273a75c0bd3825">コンストラクタ </a></p>
<div class="fragment"><div class="line">FastOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamは<b><a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> </b>でオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h3><a class="anchor" id="FastISerializer"></a>
3-4-2.回復用FastSerializer</h3>
<p><a class="el" href="classtheolizer_1_1_fast_i_serializer.html#ad8d483e11d6fe9589ab1c36bdf9d5bdf">コンストラクタ </a></p>
<div class="fragment"><div class="line">FastISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamは<b><a class="el" href="_usage_total.html#バイナリ・モード">バイナリ・モード</a> </b>でオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>FastSerializerを用いたグローバル関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>template&lt;typename tType&gt;<br />
 void copySerializable(tType const&amp; iSource, tType&amp; oDestination);</b><br />
 tType型の変数iSourceをoDestinationへコピーします。<br />
 iSourceをFastSerializerでメモリ・ストリームへシリアライズし、続けてoDestinationへ回復することでコピーします。<br />
 保存先指定も有効ですので、柔軟なデータ構造のコピーを容易に実装できます。 </div><p><br />
 </p><h6></h6>
<h1><a class="anchor" id="TestProgram"></a>
4.テスト・プログラムの構造</h1>
<h6></h6>
<p>主な機能テスト・プログラムは、 <b>source/reference_and_test</b> 以下にテストの分類に応じてフォルダを分けて入れています。</p>
<p><br />
</p>
<h2><a class="anchor" id="TestProgramStructure"></a>
4-1.構造について</h2>
<p>定義変更するということはプログラム自体が異なります。それをテストするため、変更したプログラム毎に異なるフォルダへテスト・プログラムを入れています。<br />
 保存先は、 <b>source/reference_and_test/version/ver*</b> です。 <b>ver*</b> はバージョン番号、及び、バージョン番号を変更せずにプログラム変更したもの用のフォルダ名です。<br />
 例えば、<b>ver1</b>はバージョン1用、<b>ver1a</b>はそれを少し変更したものを入れてます。</p>
<p>これらのテスト・プログラムの構造は共通です。現在は下記のような構造になっています。（機能テストの追加に伴い、ファイルと関数を追加します。）</p>
<table class="doxtable">
<tr>
<th>ファイル</th><th>関数</th><th>概要  </th></tr>
<tr>
<td>main.cpp </td><td>main()</td><td>パラメータ解析<br />
GlobalVersionNoを振ってvaryGlobalVersionNo()呼び出し </td></tr>
<tr>
<td>↑</td><td>varyGlobalVersionNo()</td><td>CheckModeを振ってvaryCheckMode()呼び出し </td></tr>
<tr>
<td>↑</td><td>varyCheckMode()</td><td>必要なシリアライザのインスタンスを生成し、saveBasic(), loadBasic()呼び出し </td></tr>
<tr>
<td>↑</td><td>saveBasic()</td><td>自動テスト基本部の保存処理。個別テストを呼び出す </td></tr>
<tr>
<td>↑</td><td>loadBasic()</td><td>自動テスト基本部の回復処理。個別テストを呼び出す </td></tr>
<tr>
<td>test_basic_process.cpp </td><td></td><td>THEOLIZER_PROCESS()の網羅的な使用例（自動テスト） </td></tr>
<tr>
<td>↑</td><td>saveBasicProcess()</td><td>保存 </td></tr>
<tr>
<td>↑</td><td>loadBasicProcess()</td><td>回復 </td></tr>
</table>
<p><br />
</p>
<h2><a class="anchor" id="MacroForDescription"></a>
4-2.説明で用いるマクロについて</h2>
<p>テスト用のマクロはtest_tool.hで定義しています。<br />
 その内、使い方の説明（兼 自動テスト）で用いるマクロについてここで簡単に説明します。</p>
<h3>THEOLIZER_EQUAL(dLhs, dRhs, ...)</h3>
<p>(dLhs == dRhs) ならばPASS、そうでないならFAILと判定します。<br />
 PASSならば、テストの数とPASS数をインクリメントします。<br />
 FAILならば、テストの数とFAIL数をインクリメントし、テストを失敗させます。<br />
 また、dRhsとそれ以降のアイテム（1個以上7個まで）を標準出力へ出力します。</p>
<p>下記はシリアライザを使って回復したint型のaIntの値が-3000であることをチェックしています。</p>
 <div class="fragment"><div class="line">    <span class="keywordtype">int</span>             aInt=0;</div><div class="line">    THEOLIZER_PROCESS(iSerializer, aInt);</div><div class="line">    <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aInt, -3000);</div></div><!-- fragment --></p>
<p><br />
</p>
<h2><a class="anchor" id="MadeTestFiles"></a>
4-3.自動テストで生成されるファイルについて</h2>
<p>自動テストで多数のファイルが<b>ビルド・フォルダ/Testing</b>配下に生成されます。<br />
 生成されるファイルは以下の通りです。<br />
</p>
<table class="doxtable">
<tr>
<th>シリアライザ</th><th>iGlobalVersionNo</th><th>iCheckMode</th><th>iNoPrettyPrint</th><th>ファイル名  </th></tr>
<tr>
<td>Json </td><td>省略 </td><td>省略 </td><td>省略 </td><td>json-default.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>NoTypeCheck </td><td>false </td><td>json-pp-verN-NoTypeCheck.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheck </td><td>false </td><td>json-pp-verN-TypeCheck.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheckByIndex</td><td>false </td><td>json-pp-verN-TypeCheckByIndex.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>NoTypeCheck </td><td>true </td><td>json-np-verN-NoTypeCheck.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheck </td><td>true </td><td>json-np-ver1-TypeCheck.json </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheckByIndex</td><td>true </td><td>json-np-ver1-TypeCheckByIndex.json </td></tr>
<tr>
<td>Binary </td><td>省略 </td><td>省略 </td><td>無し </td><td>binary-default.bin </td></tr>
<tr>
<td>↑ </td><td>N </td><td>NoTypeCheck </td><td>無し </td><td>binary-verN-NoTypeCheck.bin </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheck </td><td>無し </td><td>binary-verN-TypeCheck.bin </td></tr>
<tr>
<td>↑ </td><td>N </td><td>TypeCheckByIndex</td><td>無し </td><td>binary-verN-TypeCheckByIndex.bin </td></tr>
<tr>
<td>Fast </td><td>無し </td><td>無し </td><td>無し </td><td>fast-default.bin </td></tr>
</table>
<p>Nは当該テスト・プログラムの最新のグローバル・バージョン番号となります。<br />
 1～Nについてテストします。 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">--目次--</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>

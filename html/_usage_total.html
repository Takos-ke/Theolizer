<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theolizer: 使用方法（全体）</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Theolizer
   &#160;<span id="projectnumber">Version.1.1.3-Prerelease.</span>
   </div>
   <div id="projectbrief">serializer for C++ / Do you want to update your classes easily ?</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_usage_total.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">使用方法（全体） </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ここでは、Theolizerの使い方を説明します。</p>
<p>TheolizerはAPIの機能テストをできるだけ自動化してます。<br />
 そして、APIの機能テストは詳細仕様を規定することでもあります。複雑なプログラムでは文書として読み取ることは困難ですが、単純なプログラムであれば、文書としての機能を果たせるのではないかと考えています。</p>
<p>そこで、各機能についてそれをテストするための多数のテスト群の内、代表的なものを使って説明し、詳細テストの関連部分のソースも提示します。できるだけ読み取るのに苦労しない形式でプログラムを記述し、詳細仕様書として有用であることを目指します。</p>
<p>まず、1～3節で全体的な説明を行い、4節以降で各機能について説明します。</p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Naming"></a>
1.名前の付け方</h1>
<h6></h6>
<p>TheolizerのAPIは名前空間に入れています。また、マクロは決まったプリフィクスを付けています。 少し意味を持たせていますので説明します。</p>
<h2><a class="anchor" id="Namespace"></a>
1-1.名前空間</h2>
<p>ほぼ全てのシンボルを <b>theolizer</b> 名前空間へ入れています。<br />
 一部、入れると実装が難しいものについては、シンボルに <b>Theolizer</b> を含みます。<br />
 これにより既存のコードと被ることはまずない筈です。</p>
<p>次に、内部的に使用するシンボルは <b>internal</b> 名前空間へ入れています。<br />
 これらのシンボルが付けられたクラスや関数等は、Theolizerのアップデート時、上位互換性を考慮しませんので使用しないようお願いします。</p>
<h2><a class="anchor" id="MacroName"></a>
1-2.マクロ名</h2>
<p>全てのマクロは <b>THEOLIZER_</b> で始めています。<br />
 これにより既存のコードと被ることはまずない筈です。</p>
<p>次に、内部的に使用するマクロは、 <b>THEOLIZER_INTERNAL_</b> で始めています。<br />
 また、Theolizerが自動生成するマクロを、 <b>THEOLIZER_GENERATED_</b> で始めています。<br />
 これらのマクロは、Theolizerのアップデート時、上位互換性を考慮しませんので使用しないようお願いします。 <br />
 </p><h6></h6>
<h1><a class="anchor" id="BasicUsage"></a>
2.基本的な使い方</h1>
<h6></h6>
<p>Theolizerをインストールした後、あなたのデータをTheolizerでシリアライズするために、あなたのプログラムを下記の順序を守るようにして下さい。</p>
<ol type="1">
<li>Theolizerヘッダをインクルード</li>
<li>シリアライズするクラスとenum型の定義</li>
<li>Theolizerの自動生成ファイルをインクルード</li>
<li>シリアライズ処理</li>
</ol>
<h2><a class="anchor" id="TheolizerHeader"></a>
2-1.Theolizerヘッダをインクルード</h2>
<p>一部例外(*1)はありますが原則として、<b>シリアライズするクラスとenum型の定義</b> 前にシリアライザのヘッダをインクルードして下さい。<br />
</p>
<p><b>Json形式シリアライザ・ヘッダのインクルードと型定義の例：(source/samples/example/example.cpp）</b></p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializer__json_8h.html">theolizer/serializer_json.h</a>&gt;</span></div></div><!-- fragment --></p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*1) 例外：<b>非侵入型</b>(<a class="el" href="_specification.html#Basic12">1-2.シリアライズ可能な型についての補足事項</a>)のクラスやenum型の<b>非侵入型完全自動</b>については、<b>シリアライザのヘッダをインクルード</b>する前でも定義できます。<br />
 </div><p>現在、サポートしているシリアライザはJson形式、独自Binary形式、メモリ内専用のFast形式の3種類です。 それぞれ、下記ヘッダをインクールドして下さい。</p>
<table class="doxtable">
<tr>
<th>形式</th><th>インクルードするヘッダ</th><th>注意事項  </th></tr>
<tr>
<td>Json形式</td><td>&lt;<a class="el" href="serializer__json_8h.html" title="Jsonシリアライザ ">theolizer/serializer_json.h</a>&gt;</td><td>fstreamはテキスト・モードでオープンする </td></tr>
<tr>
<td>独自Binary形式</td><td>&lt;<a class="el" href="serializer__binary_8h_source.html">theolizer/serializer_binary.h</a>&gt;</td><td>fstreamは<b>バイナリ・モード(std::ios_base::binary)</b>でオープンする </td></tr>
<tr>
<td>メモリ内専用Fast形式</td><td>上記のどちから、もしくは、&lt;<a class="el" href="serializer_8h.html" title="TheolizerライブラリのAPI部 ">theolizer/serializer.h</a>&gt;</td><td>fstreamは<b>バイナリ・モード(std::ios_base::binary)</b>でオープンする </td></tr>
</table>
<p><br />
</p>
<h2><a class="anchor" id="DefineClassEnum"></a>
2-2.シリアライズするクラスとenum型の定義</h2>
<p><b>シリアライズするクラスとenum型の定義</b>後に、<b>Theolizerの自動生成ファイルをインスクルード</b> します。この順序に例外はありません。<br />
</p>
<p>なお、シリアライズ対象の型を含まないヘッダ・ファイルは、Theolizerに関する順序制限はありません。</p>
<h2><a class="anchor" id="IncludeAutoGeneratedFile"></a>
2-3.Theolizerの自動生成ファイルをインクルード</h2>
<p><a class="el" href="_abstract.html#Mechanism">4.Theolizerの仕組み</a> で説明したようにTheolizerはシリアライズに必要なソース・コードを自動生成します。<br />
 このファイルはコンパイル単位（通常は.cppファイル）毎に生成され、当該.cppファイルと同じフォルダへ自動的に生成されます。<br />
 Theolizerは、バージョンを上げた時に古いクラス定義やenum型定義をここに残します。これにより古いシリアライズ・データを回復できます。<br />
 そこで、このファイルをお使いのバージョン管理システム（gitやsvn等）へ登録することをお勧めします。</p>
<p>自動生成するファイルのファイル名は、そのコンパイル単位のファイル名に".theolzier.hpp"を繋げたものです。<br />
 例えば、<b>example.cpp</b> の場合は、<b>example.cpp.theolizer.hpp</b> となります。</p>
<p><b>クラス定義と*.theolizer.hppインクルード指定例：(source/samples/example/example.cpp）</b></p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serializer__json_8h.html">theolizer/serializer_json.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Foo</div><div class="line">{</div><div class="line">    std::string name;</div><div class="line">    <span class="keywordtype">int</span> age;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;example.cpp.theolizer.hpp&quot;</span>            <span class="comment">// Theolizer自動生成先</span></div></div><!-- fragment --></p>
<p>この例では、example.cppの頭でクラスを定義していますが、example.hで定義し、#include "example.h" にてインクルードするのが一般的です。</p>
<h2><a class="anchor" id="SerializingProcess"></a>
2-4.シリアライズ処理</h2>
<p>シリアライズは下記の３つで行います。</p><ul>
<li>シリアライザ・インスタンスの生成</li>
<li>シリアライズ処理要求（シリアライズするインスタンスを指定する）</li>
<li>シリアライザ・インスタンスの破棄</li>
</ul>
<h3><a class="anchor" id="ConstructSerializer"></a>
2-4-1.シリアライザ・インスタンスの生成</h3>
<p>その際、シリアライズ先のデータ・ストリームを指定します。ファイル・ストリームや<a href="http://localhost/theolizer/tcp_ip_sample/">TCP/IPストリーム</a>を指定して下さい。<br />
 保存や送信時はstd::ostreamを、回復や受信時はstd::istreamを与えて下さい。</p>
<ul>
<li><b>保存（送信用）シリアライザ</b> <br />
 <a class="el" href="classtheolizer_1_1_json_o_serializer.html" title="保存用JsonSerializer ">theolizer::JsonOSerializer</a><br />
 <a class="el" href="classtheolizer_1_1_binary_o_serializer.html" title="保存用BinarySerializer ">theolizer::BinaryOSerializer</a><br />
 <a class="el" href="classtheolizer_1_1_fast_o_serializer.html" title="保存用FastSerializer ">theolizer::FastOSerializer</a><br />
</li>
<li><b>回復（受信用）シリアライザ（デシリアライザ）</b> <br />
 <a class="el" href="classtheolizer_1_1_json_i_serializer.html" title="回復用JsonSerializer ">theolizer::JsonISerializer</a><br />
 <a class="el" href="classtheolizer_1_1_binary_i_serializer.html" title="回復用BinarySerializer ">theolizer::BinaryISerializer</a><br />
 <a class="el" href="classtheolizer_1_1_fast_i_serializer.html" title="回復用FastSerializer ">theolizer::FastISerializer</a><br />
</li>
</ul>
<h3><a class="anchor" id="Request"></a>
2-4-2.シリアライズ処理要求</h3>
<p>下記マクロでシリアライズします。保存用シリアライザを指定すると保存、回復用シリアライザを指定すると回復動作となります。<br />
 これはいつくでも記述して良いです。</p>
<p><b><a class="el" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b" title="通常の保存／回復処理マクロ（2-4-2.シリアライズ処理要求 参照） ">THEOLIZER_PROCESS(dSerializer, dInstance)</a></b></p><ul>
<li>dSerializer : シリアライザのインスタンスを指定します。<br />
</li>
<li>dInstance : 保存／回復するインスタンスを指定します。<br />
</li>
</ul>
<p>dInstanceを保存／回復します。<br />
 ポインタ型を指定した場合は、アドレス回復のためにポイント先のオブジェクト追跡を行います。<br />
</p>
<p><b><a class="el" href="serializer_8h.html#a97d7bdcabf66a9a84a5aa0241b9db848" title="被ポインタ用の保存／回復処理マクロ（2-4-2.シリアライズ処理要求 参照） ">THEOLIZER_PROCESS_POINTEE(dSerializer, dInstance)</a></b></p><ul>
<li>dSerializer : シリアライザのインスタンスを指定します。<br />
</li>
<li>dInstance : 保存／回復する被ポインタでもあるインスタンスを指定します。<br />
</li>
</ul>
<p><b><a class="el" href="serializer_8h.html#a82673dbf10780d386eb1003543d5816b" title="オーナ・ポインタ用の保存／回復処理マクロ（2-4-2.シリアライズ処理要求 参照） ">THEOLIZER_PROCESS_OWNER(dSerializer, dInstance)</a></b></p><ul>
<li>dSerializer : シリアライザのインスタンスを指定します。<br />
</li>
<li>dInstance : 保存／回復する所有権を持つインスタンスへのポインタを指定します。<br />
</li>
</ul>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="_object_tracking.html">オブジェクト追跡について</a></dd></dl>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> このようにシリアライザを問わず、全て同じマクロでシリアライズ処理できます。<br />
 xmlも将来的にサポートする予定ですが、その際も同じマクロで対応できる筈です。<br />
 （マクロなので、#演算によりインスタンス名をC言語文字列として取り出して用います。） </div><h3><a class="anchor" id="DestructSerializer"></a>
2-4-3.シリアライザ・インスタンスの破棄</h3>
<p>最後にシリアライザ・インスタンスを破棄することでシリアライズ処理を完了します。<br />
 生成時に例外発生を禁止していた場合に、エラー状態をリセットしないまま破棄すると、プロセスをアボートします。これはエラー状態の見逃しを回避するための仕様です。<br />
 例外発生を禁止している場合は、破棄する前には必ずエラー情報をチェクした上で、エラー状態をリセットして下さい。<br />
 具体的手順は<a class="el" href="_error_report.html">エラー報告</a> にて説明します。</p>
<p><b>ファイルへの保存例：(source/samples/example/example.cpp）</b></p>
 <div class="fragment"><div class="line">    <span class="comment">// 保存</span></div><div class="line">    {</div><div class="line">        Foo foo;</div><div class="line">        foo.name=<span class="stringliteral">&quot;Taro Yamada&quot;</span>;</div><div class="line">        foo.age=22;</div><div class="line"></div><div class="line">        std::ofstream ofs(<span class="stringliteral">&quot;sample.txt&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> jos(ofs);  <span class="comment">// シリアライザを生成</span></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(jos, foo);            <span class="comment">// ファイルへfooを保存</span></div><div class="line">    }</div></div><!-- fragment --></p>
<p><b>ファイルからの回復例：(source/samples/example/example.cpp）</b></p>
<p><div class="fragment"><div class="line">    <span class="comment">// 回復</span></div><div class="line">    {</div><div class="line">        Foo foo;</div><div class="line">        std::ifstream ifs(<span class="stringliteral">&quot;sample.txt&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_i_serializer.html">theolizer::JsonISerializer&lt;&gt;</a> jis(ifs);  <span class="comment">// デシリアライザを生成</span></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(jis, foo);            <span class="comment">// ファイルからfooを回復</span></div><div class="line"></div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> jos(std::cout);</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(jos, foo);            <span class="comment">// 回復結果の簡易表示</span></div><div class="line">    }</div></div><!-- fragment --></p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Serializers"></a>
3.各シリアライザの説明</h1>
<h6></h6>
<p>現在、サポートしているシリアライザはJson形式、独自Binary形式、メモリ内専用のFast形式の3種類です。<br />
 ここではそれぞれの使い方を説明します。</p>
<p><br />
</p>
<h2><a class="anchor" id="Serializer"></a>
3-1.共通事項</h2>
<p>全てのシリアライザについて共通な事項について説明します。</p>
<h3><a class="anchor" id="CheckMode"></a>
3-1-1.型チェック・モード</h3>
<p>Theolizerのシリアライザは回復時に型が一致していることをチェックできます。<br />
 その方法としてシリライズ・データ内に「型名を保存する方法」と「型に割り当てたインデックス番号（TypeIndex）を保存する方法」の２種類を用意しています。</p>
<p><a class="el" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e" title="型チェック・モード ">theolizer::CheckMode</a> </p><table class="doxtable">
<tr>
<th>列挙値</th><th>意味  </th></tr>
<tr>
<td>NoTypeCheck</td><td>型チェック無し </td></tr>
<tr>
<td>TypeCheck</td><td>型名による型チェック </td></tr>
<tr>
<td>TypeCheckByIndex</td><td>TypeIndexによる型チェック </td></tr>
</table>
<p>NoTypeCheckは型情報をシリライズ・データに含みませんのでデータ量が少ない場合の効率は良いです。しかし、メンバ名をヘッダではなくデータ側に含むためデータ量が多くなると効率は悪化します。<br />
 TypeCheckはテキスト型の場合、データを目視確認し易いです。データ量が少ない時の効率はNoTypeCheckの次に良いです。<br />
 TypeCheckByIndexはデータ量が多い時は３種のCheckModeの中で最大の効率を発揮します。</p>
<p>型情報等の管理データを下記のように記録します。</p><ul>
<li><b>シリアライズ・データのヘッダ部</b><br />
 <b>NoTypeCheck：</b>型情報を記録しません。<br />
 <b>TypeCheck：</b>クラスについて、各メンバのメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）と型名を記録します。<br />
 <b>TypeCheckByIndex：</b>全ての型について、TypeIndexに対応する型名を記録します。 更にクラスについては、各メンバのメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）とTypeIndexを記録します。<br />
 <br />
</li>
<li><b>シリアライズ・データの各データ部</b><br />
 <b>NoTypeCheck：</b>クラスについて、各メンバのデータとメンバ名（<a class="el" href="_specification.html#Basic121">名前対応</a>時）をセットで記録します。<br />
 <b>TypeCheck：</b><a class="el" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b" title="通常の保存／回復処理マクロ（2-4-2.シリアライズ処理要求 参照） ">THEOLIZER_PROCESS()</a>マクロで指定したデータと共にその型名を記録します。<br />
 <b>TypeCheckByIndex：</b><a class="el" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b" title="通常の保存／回復処理マクロ（2-4-2.シリアライズ処理要求 参照） ">THEOLIZER_PROCESS()</a>マクロで指定したデータと共にそのTypeIndexを記録します。<br />
</li>
</ul>
<p>回復時に回復先の変数の型と上記の情報と照らし合わせることで型チェックを行います。<br />
</p>
<h3><a class="anchor" id="MemberFunctions"></a>
3-1-2.メンバ関数</h3>
<p>幾つかの制御のため、各シリアライザは下記のメンバ関数を公開しています。</p>
<table class="doxtable">
<tr>
<th>メンバ名</th><th>意味  </th></tr>
<tr>
<td>unsigned getGlobalVersionNo() const;</td><td>処理中のグローバル・バージョン番号を返却します。 </td></tr>
<tr>
<td>void clearTracking() ;</td><td>オブジェクト追跡の区切り（<a class="el" href="_object_tracking.html">オブジェクト追跡について</a> 参照） </td></tr>
<tr>
<td>bool getRequireClearTracking() const;</td><td>clearTracking()が必要な時trueを返却します。 </td></tr>
<tr>
<td><a class="el" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e" title="型チェック・モード ">theolizer::CheckMode</a> getCheckMode() const;</td><td>現在のCheckModeを返却します。 </td></tr>
<tr>
<td>void setCharIsMultiByte();</td><td>Windowsにおいて、EncodedStringがtrueのシリアライザにおいて<br />
std::string変数の文字エンコードをMultiByte文字列として処理するかどうかを指定します。 </td></tr>
<tr>
<td><a class="el" href="classtheolizer_1_1_error_info.html" title="エラー情報 ">theolizer::ErrorInfo</a> const&amp; getErrorInfo() const;</td><td>エラー情報を返却します。 </td></tr>
<tr>
<td>bool isError() const;</td><td>エラーが発生している時trueを返却します。 </td></tr>
<tr>
<td>void resetError();</td><td>エラー状態を解除します。（<a class="el" href="_error_report.html#ErrorReport3">3.Theolizerで検出したエラーの通知方法</a> 参照） </td></tr>
</table>
<h3><a class="anchor" id="Property"></a>
3-1-3.プロパティ</h3>
<p>各シリアライザは、その属性をプロバティとして提供しています。</p>
<table class="doxtable">
<tr>
<th>プロバティ名</th><th>意味</th><th>Json</th><th>Binary</th><th>Fast  </th></tr>
<tr>
<td>IsSaver</td><td>保存処理用ならtrue、回復処理用ならfalse</td><td>&ndash;</td><td>&ndash;</td><td>&ndash; </td></tr>
<tr>
<td>EncodedString</td><td>文字列のエンコードを処理する</td><td>true</td><td>false</td><td>false </td></tr>
<tr>
<td>SupportModifying</td><td>クラスやenum型の定義変更に対応する</td><td>true</td><td>true</td><td>false </td></tr>
<tr>
<td>BinaryOpen</td><td>fstreamをstd::ios_base::binaryモードでオープンする必要がある&lt;td&gt;false</td><td>true</td><td>true </td></tr>
</table>
<p>プロパテイは以下の構文で受け取ります。</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <span class="keyword">property</span> = &lt;シリアライザ・クラス&gt;::hasProperty(<a class="code" href="namespacetheolizer.html#a69382907eaaeffed2214b6ccde8ce648">theolizer::Property</a>::&lt;プロパティ名&gt;);</div></div><!-- fragment --><p> <br />
</p>
<h3><a class="anchor" id="EncodedString"></a>
3-1-4.EncodedStringについて補足</h3>
<p>テキスト型のシリアライザは、文字列を読める形式で記録されます。<br />
 そのため、例えばJsonフォーマットはデフォルトではUTF-8でエンコードすると規定されています。<br />
 そして、C++の各<code>std::string</code>シリーズもUnicodeでエンコードされることが期待されます。（そうしないことも可能です。）</p>
<p>そこで、TheolizerのEncodedStringプロパティをサポートしたシリアライザ（現在はJsonのみ）は、下記のように<code>std::string</code>シリーズを処理します。</p>
<ul>
<li><b>setCharIsMultiByte(false)</b>（デフォルト）<br />
 全ての文字列を特定のUnicodeエンコードで記録する。(JsonシリアライザはUTF-8)<br />
 <code>std::string</code>はUnicodeでエンコードされているものとして処理する。（そのまま保存／回復する。）<br />
 以下は全てUnicodeへ変換して保存し、読み出し後当該エンコードへ変換する。<br />
 <code>std::wstring</code>はUTF-16かUTF-32(wchar_tのサイズによる）でエンコードされているものとして処理する。<br />
 <code>std::u16string</code>はUTF-16でエンコードされているものとして処理する。<br />
 <code>std::u32string</code>はUTF-32でエンコードされているものとして処理する。<br />
 <br />
</li>
<li><b>setCharIsMultiByte(true)</b><br />
 std::stringはMultiByte文字列としてエンコードされているものとして処理する。(Unicodeへ変換して保存／回復する。）<br />
 その他は、デフォルトと同じ。<br />
</li>
</ul>
<p>つまり、例えば、UTF-8でエンコードされた<code>std::string</code>型の変数を保存し、それをUTF-16でエンコードされた<code>std::u16string</code>型の変数へ回復できます。</p>
<p><b>サンプル・ソース（source/reference_and_test/basic/test_basic_process.cpp）</b><br />
</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div><div class="line">    <span class="comment">// CP932で&quot;[こんにちは。]&quot;</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> gHelloCP932[] = <span class="stringliteral">&quot;\x5B\x82\xB1\x82\xF1\x82\xC9\x82\xBF\x82\xCD\x81\x42\x5D&quot;</span>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">// UTF-8で&quot;[こんにちは。]&quot;  非Windows用</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> gHelloCP932[] = u8<span class="stringliteral">&quot;[こんにちは。]&quot;</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="keywordtype">void</span> tutoriseBasic()</div><div class="line">{</div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"><span class="comment">//      保存</span></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line">    {</div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;tutorise_basic.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; Shift-JISコードのテスト &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// MultiByte指定</span></div><div class="line">        aSerializer.setCharIsMultiByte(<span class="keyword">true</span>);</div><div class="line">        std::string aString = gHelloCP932;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line"></div><div class="line">        <span class="comment">// UTF-8へ戻す</span></div><div class="line">        aSerializer.setCharIsMultiByte(<span class="keyword">false</span>);</div><div class="line">        aString = u8<span class="stringliteral">&quot;ユニコードＵＴＦ－８&quot;</span>;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 文字列互換テスト &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// charをwchar_t, char16_t, char32_tへ回復</span></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"><span class="comment">//      回復</span></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line">    {</div><div class="line">        std::ifstream   aStream(<span class="stringliteral">&quot;tutorise_basic.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_i_serializer.html">theolizer::JsonISerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; Shift-JISコードのテスト &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// MultiByte指定</span></div><div class="line">        aSerializer.setCharIsMultiByte(<span class="keyword">true</span>);</div><div class="line">        std::string aString = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aString, gHelloCP932);</div><div class="line"></div><div class="line">        <span class="comment">// UTF-8へ戻す</span></div><div class="line">        aSerializer.setCharIsMultiByte(<span class="keyword">false</span>);</div><div class="line">        aString = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aString);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aString, u8<span class="stringliteral">&quot;ユニコードＵＴＦ－８&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 文字列互換テスト &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        std::wstring   aWString;</div><div class="line">        std::u16string aU16String;</div><div class="line">        std::u32string aU32String;</div><div class="line"></div><div class="line">        <span class="comment">// charをwchar_t, char16_t, char32_tへ回復</span></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aWString);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aWString, L<span class="stringliteral">&quot;ユニコードＵＴＦ－８&quot;</span>);</div><div class="line"></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aU16String);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aU16String, u<span class="stringliteral">&quot;ユニコードＵＴＦ－８&quot;</span>);</div><div class="line"></div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aU32String);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aU32String, U<span class="stringliteral">&quot;ユニコードＵＴＦ－８&quot;</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></p>
<h3><a class="anchor" id="BinaryOpen"></a>
3-1-5.BinaryOpenについて補足</h3>
<p>バイナリ形式のシリアライザをfstreamで用いる時は、必ずバイナリ・モード（std::ios_base::binary）でfstreamをオープンする必要があります。<br />
 Windowsの場合、fstreamがテキスト・モードでオープンされ、ストリームへ数値26(0x1A)が出力されると、0x1AはWindowsではEOFコードなので回復時にEOFエラーになります。また、Windowsで数値10(0x0A)が出力されるとCR LFへ展開されてしまい、適切に回復できません。<br />
 このような事態をさけるため、Theolizer側でエラーにしたいのですが、iostreamではそのオープン・モードを確認できないためチェックが困難なのです。<br />
</p>
<p>バイナリ形式のシリアライザは、hasProperty(theolzier::Property::BinaryOpen)がtrueになります。 また、各シリアライザはstd::ios_base::openmode型の静的定数kOpenModeを定義しています。 バイナリ形式のシリアライザではstd::ios_base::binary、それ以外のシリアライザで 0 となっています。</p>
<p><b>サンプル・ソース（source/reference_and_test/basic/test_basic_process.cpp）</b><br />
</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// Json</span></div><div class="line">    {</div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;openmode_json.json&quot;</span>, <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;::kOpenMode</a>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line">        <span class="keywordtype">int</span>     aInt=0x1a;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aInt);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Binary</span></div><div class="line">    {</div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;openmode_binary.bin&quot;</span>, <a class="code" href="classtheolizer_1_1_binary_o_serializer.html">theolizer::BinaryOSerializer&lt;&gt;::kOpenMode</a>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_binary_o_serializer.html">theolizer::BinaryOSerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line">        <span class="keywordtype">int</span>     aInt=0x1a;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aInt);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> <br />
</p>
<h2><a class="anchor" id="JsonSerializer"></a>
3-2.Json形式（JsonSerializer）</h2>
<p>Json形式でシリアライズする場合は、<b><a class="el" href="serializer__json_8h.html" title="Jsonシリアライザ ">theolizer/serializer_json.h</a></b>をインクルードして下さい。</p>
<h3><a class="anchor" id="JsonOSerialzier"></a>
3-2-1.保存用JsonSerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_json_o_serializer.html#a8e750bcb8c34016ed4fe755cca9ffd41">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">JsonOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">unsigned</span> iGlobalVersionNo=kLastGlobalVersionNo,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode=CheckMode::NoTypeCheck,</div><div class="line">    <span class="keywordtype">bool</span> iNoPrettyPrint=<span class="keyword">false</span>,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><p><a class="el" href="classtheolizer_1_1_json_o_serializer.html#a974a676a08fd3076e5b23505d04f38e7">GlobalVersionNo以外のオプションを指定するコンストラクタ </a></p>
<div class="fragment"><div class="line">JsonOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode,</div><div class="line">    <span class="keywordtype">bool</span> iNoPrettyPrint=<span class="keyword">false</span>,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamはテキスト・モードでオープンして下さい） </td></tr>
<tr>
<td>iGlobalVersionNo</td><td>保存するグローバル・バージョン番号(省略時は最新版) </td></tr>
<tr>
<td>iCheckMode</td><td>型チェック・モード（省略時はNoTypeCheck) </td></tr>
<tr>
<td>iNoPrettyPrint</td><td>整形出力しない時true（省略時はfalse) </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>専用継承関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>void setCharIsMultiByte(bool iCharIsMultiByte);</b><br />
 iCharIsMultiByte=trueの時、std::stringをWindowsマルチ・バイト文字コードとして取り扱います。<br />
 コンストラクト直後はiCharIsMultiByte=falseです。<br />
 Windowsのみ機能します。それ以外のOSではUTF-8のままです。 </div><h3><a class="anchor" id="JsonISerialzier"></a>
3-2-2.回復用JsonSerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_json_i_serializer.html#ad42cf979d39c85e055e9fcad774f8185">コンストラクタ </a></p>
<div class="fragment"><div class="line">JsonISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamならテキスト・モードでオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>専用継承関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>void setCharIsMultiByte(bool iCharIsMultiByte);</b><br />
 iCharIsMultiByte=trueの時、std::stringをWindowsマルチ・バイト文字コードとして取り扱います。<br />
 コンストラクト直後はiCharIsMultiByte=falseです。<br />
 Windowsのみ機能します。それ以外のOSではUTF-8のままです。 </div><p><br />
</p>
<h2><a class="anchor" id="BinarySerializer"></a>
3-3.独自Binary形式（BinarySerializer）</h2>
<p>独自Binary形式でシリアライズする場合は、<b><a class="el" href="serializer__binary_8h_source.html">theolizer/serializer_binary.h</a></b>をインクルードして下さい。<br />
</p>
<p>Big Endianでエンコードします。Little Endianの処理系の場合Big Endianとの間で自動変換します。<br />
 整数型は値を表現するために十分なバイト数で保存します。例えば、long long型でも値が10ならタグと値で合わせて2バイトで保存します。<br />
 浮動小数点型はIEEE754フォーマットのみサポートします。バイト単位でEndian変換します。<br />
 long doubleは「radix==2、digits==64、max_exponent==16384」の80ビット拡張精度形式である処理系（gcc）とbinary64である処理系(msvc)に対応しています。<br />
 文字コードの変換は行いません。Endianのみ変換してシリアライズします。<br />
</p>
<h3><a class="anchor" id="BinaryOSerialzier"></a>
3-3-1.保存用BinarySerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_binary_o_serializer.html#ae71e52ea12cc23e344f655880ec446e7">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">unsigned</span> iGlobalVersionNo=kLastGlobalVersionNo,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode=CheckMode::NoTypeCheck,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><p><a class="el" href="classtheolizer_1_1_binary_o_serializer.html#a5d883db832dda088714169b268bc09b5">GlobalVersionNo以外のオプションを指定するコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <a class="code" href="namespacetheolizer.html#afedaabb9b299538fd08e2d2ae4ccde6e">CheckMode</a> iCheckMode,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamはstd::ios_base::binaryでオープンして下さい） </td></tr>
<tr>
<td>iGlobalVersionNo</td><td>保存するグローバル・バージョン番号(省略時は最新版) </td></tr>
<tr>
<td>iCheckMode</td><td>型チェック・モード（省略時はNoTypeCheck) </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h3><a class="anchor" id="BinaryISerializer"></a>
3-3-2.回復用BinarySerialzier</h3>
<p><a class="el" href="classtheolizer_1_1_binary_i_serializer.html#a06d109cddbadd6d9b2542eaedc1a5f3c">通常のコンストラクタ </a></p>
<div class="fragment"><div class="line">BinaryISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamはstd::ios_base::binaryでオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<p><br />
</p>
<h2><a class="anchor" id="FastSerializer"></a>
3-4.メモリ内専用のFast形式（FastSerializer）</h2>
<p>FastSerializerの使用目的はデータ構造のプログラム内コピーです。外部プログラムとのデータ交換は想定していません<br />
</p>
<p>Theolizerが内部的に使用していますので、他のシリアライザのヘッダをインクルードすれば改めてヘッダをインクルードする必要はありません。<br />
 もし、他のシリアライザを使用しない時は、theolizer/serializer.hをインクルードして下さい。<br />
 また、ストリームはstd::stringstreamを用いることを想定していますが、もしも、ファイル・ストリームを与える場合は必ず std::ios_base::binaryモード でオープンして下さい。<br />
 FastSerializerはデータ変換しません。バージョンの相違にも対応していません。<br />
 オーナー指定ポインタでない通常のポインタは、ポイント先をシリアライズしていない場合はシャロー・コピーになります。（ポインタ値を単純にコピーする。）<br />
</p>
<h3><a class="anchor" id="FastOSerializer"></a>
3-4-1.保存用FastSerializer</h3>
<p><a class="el" href="classtheolizer_1_1_fast_o_serializer.html#adac5dc58f348dcab99273a75c0bd3825">コンストラクタ </a></p>
<div class="fragment"><div class="line">FastOSerializer</div><div class="line">(</div><div class="line">    std::ostream&amp; iOStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iOStream</td><td>出力先のストリーム(ofstreamはstd::ios_base::binaryでオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h3><a class="anchor" id="FastISerializer"></a>
3-4-2.回復用FastSerializer</h3>
<p><a class="el" href="classtheolizer_1_1_fast_i_serializer.html#ad8d483e11d6fe9589ab1c36bdf9d5bdf">コンストラクタ </a></p>
<div class="fragment"><div class="line">FastISerializer</div><div class="line">(</div><div class="line">    std::istream&amp; iIStream,</div><div class="line">    <span class="keywordtype">bool</span> iNoThrowException=<span class="keyword">false</span></div><div class="line">);</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>パラメータ名</th><th>意味  </th></tr>
<tr>
<td>iIStream</td><td>入力元のストリーム(ofstreamはstd::ios_base::binaryでオープンして下さい） </td></tr>
<tr>
<td>iNoThrowException</td><td>例外禁止時true（省略時はfalse) </td></tr>
</table>
<h4>FastSerializerを用いたグローバル関数</h4>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>template&lt;typename tType&gt;<br />
 void copySerializable(tType const&amp; iSource, tType&amp; oDestination);</b><br />
 tType型の変数iSourceをoDestinationへコピーします。<br />
 iSourceをFastSerializerでメモリ・ストリームへシリアライズし、続けてoDestinationへ回復することでコピーします。<br />
 保存先指定も有効ですので、柔軟なデータ構造のコピーを容易に実装できます。 </div><p><br />
 </p><h6></h6>
<h1><a class="anchor" id="TestProgram"></a>
4.テスト・プログラムの構造</h1>
<h6></h6>
<p><br />
</p>
<h2><a class="anchor" id="TestProgram41"></a>
4-1.テスト・プログラムの全体構造</h2>
<h3><a class="anchor" id="TestProgram411"></a>
4-1-1.アップデートとバージョンのバリエーション</h3>
<p>主な機能テスト・プログラムは、 <b>source/reference_and_test</b> 以下にアップデート／バージョン・アップによる変更（修正版）毎にフォルダを分けて保存しています。</p>
<p>Theolizerはenum型とclass/struct型について定義変更に対応しています。そのテストも行うため、以下のように分類してテストを行います。</p>
<ol type="1">
<li>基本的なシリアライズ機能の定義変更を除く様々なバリエーションのテスト</li>
<li>バージョン番号を更新しない定義変更のテスト</li>
<li>バージョン番号を更新する定義変更のテスト</li>
</ol>
<p>現時点では下記修正版を用意しています。</p>
<table class="doxtable">
<tr>
<th>フォルダ名</th><th>バージョン番号</th><th>説明  </th></tr>
<tr>
<td>basic</td><td>無し</td><td>基本的なシリアライズ機能の定義変更を除く様々なバリエーションのテスト </td></tr>
<tr>
<td>basic2</td><td>無し</td><td>同上 </td></tr>
<tr>
<td>ver1a</td><td>1</td><td>最初のバージョン </td></tr>
<tr>
<td>ver1b</td><td>1</td><td>バージョン番号を変えずに可能な定義変更のテスト </td></tr>
<tr>
<td>ver1c</td><td>1</td><td>バージョン番号を変えるための準備のテスト </td></tr>
<tr>
<td>ver2a</td><td>2</td><td>バージョン番号を変更した時の定義変更のテスト </td></tr>
<tr>
<td>ver3a</td><td>3</td><td>更にバージョン番号を変更のテスト </td></tr>
<tr>
<td>ver3b</td><td>3</td><td>そしてバージョン番号を変えずに定義変更のテスト </td></tr>
</table>
<p>class/structでメンバ変数を削除した場合、１つ前のバージョンの自動生成ソースに削除されたことを反映します。なので、最新版と１つ前のバージョンと、更にもう１つ前に問題が出ないかテストするため、３つのバージョンでテストします。</p>
<p>各変更テスト・プログラムは他の変更テスト・プログラムが出力したデータを読み込んで回復できることやエラーを検出できることをテストします。</p>
<h3><a class="anchor" id="TestProgram412"></a>
4-1-2.テストの組み合わせ</h3>
<p>下記組み合わせとなります。１行毎に各修正版プログラムが出力するデータ概要を記述しています。<br />
 列に記載した各バージョンのプログラムが当該データの回復テストをする時◯印を付けています。</p>
<table class="doxtable">
<tr>
<th>プロ<br />
グラ<br />
ム</th><th>バー<br />
ジョン<br />
指定</th><th>ファイル名</th><th>basic</th><th>basic2</th><th>ver1a</th><th>ver1b</th><th>ver1c</th><th>ver2a</th><th>ver3a</th><th>ver3b  </th></tr>
<tr>
<td>basic </td><td>指定無し </td><td>①-basic-② </td><td>◯ </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>basic </td><td>1 </td><td>①-basic-basic-② </td><td>◯ </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>basic2</td><td>指定無し </td><td>①-basic2-②</td><td></td><td>◯ </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>basic2</td><td>1 </td><td>①-basic-basic2-② </td><td></td><td>◯ </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ver1a </td><td>指定無し </td><td>①-ver1a-② </td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver1a </td><td>1 </td><td>①-ver1a-ver1a-② </td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver1b </td><td>指定無し </td><td>①-ver1b-② </td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver1b </td><td>1 </td><td>①-ver1b-ver1b-② </td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver1c </td><td>指定無し </td><td>①-ver1c-② </td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver1c </td><td>1 </td><td>①-ver1c-ver1c-② </td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver2a </td><td>指定無し </td><td>①-ver2a-② </td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver2a </td><td>1 </td><td>①-ver1c-ver2a-② </td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver2a </td><td>2 </td><td>①-ver2a-ver2a-② </td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3a </td><td>指定無し </td><td>①-ver3a-② </td><td></td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3a </td><td>1 </td><td>①-ver1c-ver3a-② </td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3a </td><td>2 </td><td>①-ver2a-ver3a-② </td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3a </td><td>3 </td><td>①-ver3a-ver3a-② </td><td></td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3b </td><td>指定無し </td><td>①-ver3b-② </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>◯ </td></tr>
<tr>
<td>ver3b </td><td>1 </td><td>①-ver1c-ver3b-② </td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3b </td><td>2 </td><td>①-ver2a-ver3b-② </td><td></td><td></td><td></td><td></td><td></td><td>◯ </td><td>◯ </td><td>◯ </td></tr>
<tr>
<td>ver3b </td><td>3 </td><td>①-ver3b-ver3b-② </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>◯ </td></tr>
</table>
<p>①にはシリアライザ名と一部のオプションが入ります。</p>
<ul>
<li>json-np (非整形出力)</li>
<li>json-pp (整形出力)</li>
<li>binary</li>
<li>fast</li>
</ul>
<p>②は以下の通りです。</p>
<ul>
<li>残りのオプション指定<ul>
<li>jsonとbinaryの場合<ul>
<li>NoTypeCheck</li>
<li>TypeCheck</li>
<li>TypeCheckByIndex</li>
</ul>
</li>
<li>fastの場合は、最新版のみ対応でオプションもないため、上記表の「指定無し」のみです。 <br />
<br />
</li>
</ul>
</li>
<li>保存先指定用のサフィックス<ul>
<li>無印</li>
<li>A(保存先DestA)</li>
<li>B(保存先DestB)</li>
<li>AB(保存先DestA | DestB) <br />
<br />
</li>
</ul>
</li>
<li>拡張子<ul>
<li>jsonの拡張子はjson</li>
<li>binaryとfastの拡張子はbin</li>
</ul>
</li>
</ul>
<p>例えば、json整形出力で、ver3aのプログラムがver1cデータを型チェック無し、保存先指定無しで出力したファイル名は、"json-pp-ver1c-ver3a-NoTypeCheck.json"となります。</p>
<p><br />
</p>
<h2><a class="anchor" id="TestProgram42"></a>
4-2.テスト・プログラムの構造</h2>
<p>basic、および、各変更テスト用プログラムは共通部分があります。それらはreference_and_testフォルダ直下に配置し、ビルドする時に各サブ・フォルダへコピーしています。</p>
<h3>共通部</h3>
<table class="doxtable">
<tr>
<th>ファイル</th><th>関数</th><th>概要  </th></tr>
<tr>
<td>disable_test.h </td><td></td><td>各個別テストをディセーブルするシンボル定義。<br />
デバッグ時の便利のために用意。 </td></tr>
<tr>
<td>all_common.h </td><td></td><td>テスト用の全バージョン共通定義。<br />
アップデートとバージョン名とバージョン番号対応表のgVersionListを定義。 </td></tr>
<tr>
<td>main.inc </td><td>main() </td><td>各サブ・フォルダ内のmain.cppから::includeされる。<br />
コマンドライン解析を行い、パラメータが無い時は保存処理、ある時は回復処理を実行する。<br />
4-1節 表の全組み合わせを生成し、callTests()を呼び出す。 </td></tr>
<tr>
<td>↑</td><td>callTests()</td><td>各シリアライザのパラメータを振ってインスタンスを生成し、<br />
saveBasic(), loadBasic(),callSaveDestinations(),callLoadDestinations()を呼び出す。 </td></tr>
</table>
<h3>各サブフォルダ部</h3>
<table class="doxtable">
<tr>
<th>ファイル</th><th>関数</th><th>概要  </th></tr>
<tr>
<td>main.cpp </td><td></td><td>各個別フォルダ内テスト関数を呼び出す。 </td></tr>
<tr>
<td>↑</td><td>saveBasic()</td><td>自動テスト基本部の保存処理。個別テストを呼び出す。 </td></tr>
<tr>
<td>↑</td><td>loadBasic()</td><td>自動テスト基本部の回復処理。個別テストを呼び出す。 </td></tr>
<tr>
<td>↑</td><td>callSaveDestinations()</td><td>自動テスト保存先指定部の保存処理。個別テストを呼び出す。 </td></tr>
<tr>
<td>↑</td><td>callLoadDestinations()</td><td>自動テスト保存先指定部の回復処理。個別テストを呼び出す。 </td></tr>
</table>
<p>各個別テストは別途*.cppファイルを用意し、その中で定義しています。<br />
 それぞれについては <a class="el" href="_usage_individual.html">使用方法（個別）</a> にて解説します。</p>
<p><br />
</p>
<h2><a class="anchor" id="TestProgram43"></a>
4-3.説明で用いるマクロについて</h2>
<p>テスト用のマクロはtest_tool.hで定義しています。<br />
 その内、使い方の説明（兼 自動テスト）で用いるマクロについてここで簡単に説明します。</p>
<p>1.<a class="el" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(dLhs, dRhs, ...)</p>
<p>(dLhs == dRhs) ならばPASS、そうでないならFAILと判定します。<br />
 PASSならば、テストの数とPASS数をインクリメントします。<br />
 FAILならば、テストの数とFAIL数をインクリメントし、テストを失敗させます。<br />
 また、dRhsとそれ以降のアイテム（1個以上7個まで）を標準出力へ出力します。</p>
<p>下記はシリアライザを使って回復したint型のaIntの値が-3000であることをチェックしています。</p>
 <div class="fragment"><div class="line">        <span class="keywordtype">int</span>     aInt=0;</div><div class="line">        <a class="code" href="serializer_8h.html#a111b2020794cbf2649488f2030c49f7b">THEOLIZER_PROCESS</a>(aSerializer, aInt);</div><div class="line">        <a class="code" href="group___test.html#ga18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aInt, 0x1a);</div></div><!-- fragment --> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
    <li class="navelem"><a class="el" href="index.html">--目次--</a></li>
		<span style="color:#364D7C";>
			&nbsp;&nbsp;&copy; 2016 <a href="http://theolizer.com/">Theoride Technology</a> All Rights Reserved.
      &nbsp;&nbsp;"Theolizer" is a registered trademark of Theoride Technology.
		</span>
    <li class="footer">
			構築:
    	<a href="http://www.doxygen.org/index.html">
    		<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>
			1.8.12
		</li>
  </ul>
</div>
</body>
</html>

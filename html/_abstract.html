<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theolizer: 概要</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Theolizer
   &#160;<span id="projectnumber">Version.1.1.3</span>
   </div>
   <div id="projectbrief">serializer for C++ / Do you want to update your classes easily ?</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_abstract.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">概要 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p><h6></h6>
<h1><a class="anchor" id="What"></a>
1.Theolizerとは</h1>
<h6></h6>
<hr/>
<p>Theolizerは<a href="https://ja.wikipedia.org/wiki/C%2B%2B11">C++11</a>で記述されたC++用のシリアライザです。<br />
 Theolizerを使うことで次のようなプログラムの開発が容易になります。</p>
<ul>
<li>クラスや構造体等とその組合せで作れられた複雑なデータ構造を</li>
<li>「ファイルへ保存／回復」するプログラム</li>
<li>「通信回線で送受信」するプログラム</li>
</ul>
<p>また、C++をベターCとしてお使いの方にも使って頂けるよう設計しておりますのでお気軽にお試し下さい。</p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Platforms"></a>
2.対応環境</h1>
<h6></h6>
<hr/>
<p>マルチ・プラットフォームでC++11規格コンパイラに対応できるよう設計しています。<br />
 現時点でテストできている環境は下記の通りです。</p>
<h2><a class="anchor" id="LastVersion"></a>
2-1.v1.1.3以降</h2>
<table class="doxtable">
<tr>
<th>OS</th><th>C++コンパイラ  </th></tr>
<tr>
<td>Windows 10 Professional 64bit</td><td><a href="https://www.visualstudio.com/ja/downloads/">Visual Studio C++ 2017</a> Community Version 15.2<br />
<a href="https://sourceforge.net/projects/mingw-w64/">MinGW 7.1.0 32bit posix dwarf</a>(mingw-w64-install.exe)<br />
<a href="https://sourceforge.net/projects/mingw-w64/">MinGW 7.1.0 64bit posix seh</a>(mingw-w64-install.exe) </td></tr>
<tr>
<td>ubuntu 16.04 LTS 64bit</td><td>gcc 5.4.0(Ubuntu 5.4.0-6ubuntu1~16.04.2) </td></tr>
</table>
<p>将来的にOS X + apple-llvmに対応する準備を進めています。<br />
 <br />
 次に、ユーザ・プログラムをビルドする際に関連するツールは以下の通りです。<br />
</p>
<table class="doxtable">
<tr>
<th>その他のツール</th><th>バージョン</th><th>備考  </th></tr>
<tr>
<td>CMake</td><td>3.8.0以上</td><td>ユーザ・プログラムのビルドをアシストする際に用います<br />
Theolizerのビルドに使用しています </td></tr>
<tr>
<td>boost</td><td>1.64.0以上</td><td>Theolizerの内部で使用しています </td></tr>
</table>
<p>CMakeは必須ではありませんが、使用することを強く推奨します。<br />
 あなたのプログラムでBoostを使っている場合、それがTheolizerで使っているものと異なるバージョンの時、注意が必要になります。「<a class="el" href="_how_to_make_project.html#Selecting">1.Theolizerライブラリの選択</a> 」を参照下さい。<br />
</p>
<p>なお、CMakeはバージョンによって認識可能なBoostのバージョンが異なります。調べた範囲では以下でした。Linuxではお使いになるBoostのバージョンに合わせて選択下さい。(WindowsではCMake 3.8.0以降のVisual Studio対応機能を用いますのでCMake 3.8.0以降のみ使用可能です。）</p>
<table class="doxtable">
<tr>
<th>CMakeバージョン</th><th>Boostバージョン  </th></tr>
<tr>
<td>3.8.0</td><td>1.64.0以下 </td></tr>
<tr>
<td>3.7.2</td><td>1.63.0以下 </td></tr>
<tr>
<td>3.7.1</td><td>1.62.0以下 </td></tr>
<tr>
<td>3.6.0</td><td>1.61.0以下 </td></tr>
<tr>
<td>3.5.1</td><td>1.61.0以下 </td></tr>
<tr>
<td>3.5.0</td><td>1.61.0以下 </td></tr>
</table>
<h2><a class="anchor" id="OldVersion"></a>
2-2.v1.1.2以前</h2>
<table class="doxtable">
<tr>
<th>OS</th><th>C++コンパイラ  </th></tr>
<tr>
<td>Windows 10 Professional 64bit</td><td><a href="https://www.microsoft.com/ja-jp/dev/products/visual-studio-2015.aspx">Visual Studio C++ 2015</a> Community update 3<br />
<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/5.4.0/threads-posix/dwarf/i686-5.4.0-release-posix-dwarf-rt_v5-rev0.7z/download">MinGW 5.4.0 32bit posix dwarf</a><br />
<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/5.4.0/threads-posix/seh/x86_64-5.4.0-release-posix-seh-rt_v5-rev0.7z/download">MinGW 5.4.0 64bit posix seh</a> </td></tr>
<tr>
<td>ubuntu 16.04 LTS 64bit</td><td>gcc 5.4.0(Ubuntu 5.4.0-6ubuntu1~16.04.2) </td></tr>
</table>
<p><br />
 次に、ユーザ・プログラムをビルドする際に関連するツールは以下の通りです。<br />
</p>
<table class="doxtable">
<tr>
<th>その他のツール</th><th>バージョン</th><th>備考  </th></tr>
<tr>
<td>CMake</td><td>Visual C++は3.8.0以上<br />
その他は3.5.0以上</td><td>ユーザ・プログラムのビルドをアシストする際に用います<br />
Theolizerのビルドに使用しています </td></tr>
<tr>
<td>boost</td><td>1.59.0以上</td><td>Theolizerの内部で使用しています </td></tr>
</table>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Features"></a>
3.Theolizerの特長</h1>
<h6></h6>
<hr/>
<h2><a class="anchor" id="Features31"></a>
3-1.自動シリアライズ</h2>
<p>C++は、クラスや構造体（以下、まとめてクラスと呼びます）に含まれるメンバのリストをプログラムがアクセスすることはできません。（メンバ1つ1つを名前を指定してアクセスすることはできますが、forループ等でメンバを次々と列挙することができないのです。） ですので、クラスをシリアライズするためにはメンバのリストを、クラス定義とは別に改めて作成する必要がありました。<br />
 Theolizerは<a href="http://llvm.org/">Clang/LLVM</a>に含まれるlibTooling<a href="http://qiita.com/Chironian/items/6021d35bf2750341d80c">libTooling</a>の構文解析機能を用いてクラス定義を解析し、メンバのリストを自動生成します。<br />
 従って、クラス定義を変更した時もメンバ・リストへの反映漏れが無く、プログラム開発が捗ります。</p>
<h2><a class="anchor" id="Features32"></a>
3-2.保存先指定</h2>
<p>１つのクラスに属するメンバ変数を保存する時、複数の異なるファイルへ保存したい時もあると思います。一部のメンバ変数は設定ファイルへ保存し、また別のメンバはデータ・ファイルへ保存したいというケースは少なくないと思います。また、一部のメンバ変数（ファイル・ハンドル等）は保存しないことも多いでしょう。<br />
 <br />
 Theolizerはメンバ変数に保存先や保存の有無を指定することでクラスを分割して異なるファイルへ保存したり、一部を通信で他のプログラムへ送信したりすることができます。</p>
<h2><a class="anchor" id="Features33"></a>
3-3.オブジェクト追跡</h2>
<p>一般にポインタをファイルへ保存し、プログラムを再起動した後でそのポインタを回復しても意味はありません。ポイント先のメモリ・アドレスはプログラムの再起動前後で異なることが一般的だからです。<br />
 <br />
 Theolizerはポイント先のデータも一緒にファイルへ保存するのであればオブジェクト追跡によりポインタを有意味に回復することができます。もちろん通信時も同様です。<br />
 また、ポイント先がクラスの場合、その各メンバに保存先指定することができますので全てを保存する必要はありません。<br />
 これにより複雑なデータ構造を容易に保存／回復・送受信できます。<br />
 オブジェクト追跡機能はboost::serializationを参考に開発しました。</p>
<h2><a class="anchor" id="Features34"></a>
3-4.プログラム変更対応</h2>
<p>シリアライザを使って保存するということは、内部データの構造を保ったままファイルへ保存するということです。内部データ構造はプログラムの変更に伴い変更されるため、旧プログラムで保存されたファイルを回復できるようにするためには内部データ構造の変更に強い制限がかかります。<br />
 <br />
 Theolizerはその制限を大幅に緩和し、古いプログラムで保存したデータを新しいプログラムで回復できます。<br />
 更に、新しいプログラムで古いプログラムが読めるデータを保存するプログラムを開発することも可能です。<br />
 <br />
 クラス(class/struct)とenum型の定義を変更するに際して、2種類の変更対応方法を用意しています。</p>
<ol type="1">
<li><b>アップデート</b><br />
 バージョン番号を変更しない方法です。</li>
<li><b>バージョン・アップ</b><br />
 クラスやenum型に割り当てた（ローカル)バージョン番号を１つ上げて対応する方法です。</li>
</ol>
<p>それぞれ特徴があります。</p>
<table class="doxtable">
<tr>
<th>方式</th><th>特徴  </th></tr>
<tr>
<td>アップデート</td><td>1.変更が容易です。<br />
2.自動生成するソース・コードが増えないためコンパイラへの負荷が軽いです。<br />
3.古いデータを新しいプログラムで回復できますが、逆はサポートしていません。 </td></tr>
<tr>
<td>バージョン・アップ</td><td>1.より大幅な変更に対応できます。<br />
2.旧バージョン形式のデータを保存することができます。<br />
3.変更作業は少し手間がかかります。<br />
4.旧バージョンの変数リストやシンボル・リストを保持するため、<br />
バージョン番号を上げる度に自動生成されるソース・コードが増えます。 </td></tr>
</table>
<p>可能な時はアップデートにて変更対応し、それでは不足の場合にバージョン・アップすることがお薦めです。<br />
 <br />
 まとめると次のような特長があります。</p>
<ol type="1">
<li><b>クラス定義、enum定義の変更（アップデート／バージョンアップ）</b><br />
<ul>
<li>クラスのメンバ変数の追加／削除／順序変更に対応しています。<br />
</li>
<li>enum型のシンボルの追加／削除／定義順序変更に対応しています。<br />
 また、シンボル名で保存／回復する時はシンボル値を、シンボル値保存の時はシンボル名を自由に変更できます。<br />
 <br />
</li>
</ul>
</li>
<li><b>クラスについてバージョン・アップ／ダウン処理を記述できます</b><br />
<ul>
<li>クラスをバージョン・アップする際に行いたい処理を記述できます。<br />
 例えば、変数にオフセットを追加した時、そのオフセットを加える処理などです。<br />
</li>
<li>バージョン・ダウン処理を定義できます。<br />
 例えば、オフセットを引く処理などです。<br />
</li>
<li>クラスは名前対応と順序対応を、enum型はシンボル名保存とシンボル値保存を切り替えることができます。<br />
 開発当初は名前対応／シンボル名保存にて変更しやすくしておき、安定したら順序対応／シンボル値保存として効率アップすることが可能です。更に元へ戻すこともできます。<br />
 <br />
</li>
</ul>
</li>
<li><b>バージョン・アップ／ダウンをカスケードに処理します</b><br />
 例えば、Ver.4をVer.5へバージョンアップした時、従来はVer.4→Ver.5のプログラム開発だけでなく、Ver.1～Ver.3→Ver.4のプログラムをVer.1～Ver.3→Ver.5へ改造する必要がありました。Theolizerはバージョン・アップ／ダウン処理をカスケード(Ver.1→Ver.2→Ver.3→Ver.4→Ver.5)に行いますので、Ver.4→Ver.5のプログラムを開発するだけで済みます。<br />
 これによりバージョンが上がった時のプログラム開発を大きく低減できます。(注)<br />
 <br />
</li>
<li><b>旧バージョン形式のデータを保存することができます</b><br />
 保存したい形式のバージョン番号を指定することで、新しいバージョンのプログラムが古いバージョンのプログラムが保存する形式でデータ保存可能です。<br />
 なお、指定された古いバージョンに複数のアップデートが含まれる場合は最後のアップデート版が保存されます。</li>
</ol>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>（注）バージョン・アップ／ダウンにおける不可逆性に注意</b><br />
 Theolizerのバージョン・ダウン機能は旧プログラムで回復可能なデータを保存することを目的としています。<br />
 <br />
 バージョン・アップする時はenum値や変数の追加を行うケースが多いですが、古い形式のデータを保存する時には、その追加されたデータを削除します。（古いバージョンのプログラムはその追加されたデータの存在を知らないため、もしも残すと古いプログラムが処理できなくなるためです。） なので、新バージョン・プログラムが保存した<b>旧バージョン</b>・データを、再度新バージョン・プロクラムで回復した時、元のデータに戻ることを本質的に期待できません。<br />
 </div><p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Mechanism"></a>
4.Theolizerの仕組み</h1>
<h6></h6>
<hr/>
<p> 　Theolizerはドライバとライブラリの２つで構成されています。</p>
<table class="doxtable">
<tr>
<th>項目 </th><th>内容  </th></tr>
<tr>
<td>ドライバ</td><td>あなたのソースを解析して、シリアライズ処理に必要なコードを自動生成します。 </td></tr>
<tr>
<td>ライブラリ</td><td>あなたのプログラムとリンクして、シリライズ処理を行います。 </td></tr>
</table>
<h2><a class="anchor" id="Mechanism41"></a>
4-1.ドライバ</h2>
<p><b>Theolizerドライバ</b>はあなたのビルド・プロジェクト（makeやVisual Studio）とコンパイラの間に割り込み、下記を自動的に行います。</p>
<ol type="1">
<li>ビルド・プロジェクトの指示に従ってあなたのソース・コードを解析します。<br />
</li>
<li>シリアライズ／デシリアライズ処理を行うために必要なソース・コード（主にクラス・メンバのリスト）を自動生成します。<br />
 C++ソース・コードの解析には、<a href="http://llvm.org/">Clang/LLVM</a>に含まれるlibToolingを用いて構文解析を行っています。</li>
<li>通常のコンパイラとリンカがあなたのプログラムと自動生成されたソース・コードをビルドし、<b>Theolizerライブラリ</b>をリンクします。<br />
</li>
</ol>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>自動生成するソースのファイル名</b><br />
 自動生成するソース・ファイル名は、コンパイルするソースファイル名.theolizer.hppです。 例えば、main.cppの場合、main.cpp.theolizer.hppとなります。 </div><h2><a class="anchor" id="Mechanism42"></a>
4-2.ライブラリ</h2>
<p><b>Theolizerライブラリ</b>はあなたのプログラムとリンクして、データ構造のシリアライズとデシリアライズを行います。</p>
<h2><a class="anchor" id="Mechanism43"></a>
4-3.Theolizerドライバが割り込む仕組み</h2>
<p>ビルド・プロジェクトとコンパイラの間にTheolizerドライバを割り込む仕組みのポイントは次の３点です。</p>
<ol type="1">
<li>ビルド・システムにTheolizerドライバをコンパイラとして起動させる</li>
<li>Theolizerドライバにソース自動生成が必要であることを伝達し、自動生成処理する</li>
<li>Theolizerドライバに元コンパイラのパスを伝達し、元のコンパイラへ処理を引き継ぐ</li>
</ol>
<h3><a class="anchor" id="Mechanism431"></a>
4-3-1. Theolizerドライバをコンパイラとして起動させる</h3>
<h4>4-3-1-1.Visual Studioの場合</h4>
<ul>
<li>Theolizerインストール時に準備<br />
 Theolizerのインストール先フォルダにmsbuild-binフォルダを追加し、そこへTheolizerドライバをcl.exeとして保存します。</li>
<li>ビルド・プロジェクト生成</li>
</ul>
<p>CMake 3.8.0にて<a href="https://cmake.org/cmake/help/v3.8/prop_tgt/VS_USER_PROPS.html">VS_USER_PROPS</a>と言うVC++のプロジェクトへインクルード指定を追加するプロパティが追加されました。<br />
 これを使ってターゲットのプロジェクト・ファイル（*.vcxproj）に<code>&lt;Import Project&gt;</code>キーを追加し、theolizer.propsをインクルードするようにしました。<br />
 そして、<code>theolizer.props</code>にて、コンパイル時に使われる<code>PATH</code>を指定する<code>&lt;ExecutablePath&gt;</code>の先頭に上記<code>msbuild-bin</code>フォルダを追加しました。<br />
</p>
<p>以上により、Theolizerを使用するプロジェクトにおいてTheolizerドライバがコンパイラとして起動します。</p>
<h4>4-3-1-2.その他（gcc/mingw)の場合</h4>
<p>対象のプロジェクトのCMAKE_CXX_COMPILERにTheolizerドライバのフルパスを設定しました。<br />
 これはmakefileのコンパイラに反映されますので、呼び出すコンパイラを変更できます。<br />
 （なお、Visual Studioはmakeではなくマイクロソフト独自のMSBuildでビルドするためこの方法が機能しません。）<br />
</p>
<h3><a class="anchor" id="Mechanism432"></a>
4-3-2.Theolizerドライバにソース自動生成が必要であることを伝達する</h3>
<p>CMakeで<code>THEOLIZER_DO_PROCESS</code>マクロをコンパイラ・オプションで定義するようにしまた。 このマクロがオプションで指定された時、Theolizerドライバはソース自動生成処理を行います。 そうでない時は、Theolizer関連オプションを除く全ての引数で元コンパイラを起動（パススルー）します。</p>
<h3><a class="anchor" id="Mechanism433"></a>
4-3-3.Theolizerドライバに元コンパイラのパスを伝達する</h3>
<h4>4-3-3-1.Visual Studioの場合</h4>
<p>CMakeは*.rspファイルに全てのオプションを記述してコンパイラへ渡します。その為、Theolizerドライバでそのオプションを削除して元コンパイラへ引き継ぐことが難しいです。しかし、削除しないとcl.exeが「知らないオプション」として警告します。 そこで、マクロ定義（<code>/Dtheolizer_original_compiler=&lt;元コンパイラのパス&gt;</code>）で伝達することで警告表示されないようにしました。マクロ定義はリンカへ伝達する必要がないので伝わらないようです。</p>
<h4>4-3-3-2.その他（gcc/mingw)の場合</h4>
<p>CMakeはgcc/mingw用にはコンパイルとリンクを分解してg++を呼び出します。 リンクの時ldを直接呼ぶわけでなく、g++にリンク指定して呼び出します。 どちらの場合もTheolizerドライバが起動されることになります。 そして、リンク動作時は<code>-D</code>オプションは渡ってきません。マクロ定義はコンパイラのみ必要なオプションだからだと思います。 しかし、その結果、リンク時に起動されたTheolizerドライバが元コンパイラのパスを得ることができず、元コンパイラをパススルー起動できません。</p>
<p>そこで、msvc以外の時は<code>--theolizer_original_compiler=&lt;元コンパイラのパス&gt;</code>オプションで元コンパイラのパスを伝達するようにしました。</p>
<h3><a class="anchor" id="Mechanism434"></a>
4-3-4. 使い方の変更について</h3>
<p>上記はfind_packageで用いるTHEOLIZERConfig.cmake内部で対応しました。ですので、ユーザ・プログラム用のCMakeLists.txtは従来のままで使用できます。従来必要であったコンパイラのリプレース操作が不要になります。<br />
</p>
<p>なお、Visual Studioをお使いの場合は、CMakeを3.8.0以上へアップデートする必要があります。 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<ul>
    <li class="navelem"><a class="el" href="index.html">--目次--</a></li>
		<span style="color:#364D7C";>
			&nbsp;&nbsp;&copy; 2016 <a href="http://theolizer.com/">Theoride Technology</a> All Rights Reserved.
      &nbsp;&nbsp;"Theolizer" is a registered trademark of Theoride Technology.
		</span>
    <li class="footer">
			構築:
    	<a href="http://www.doxygen.org/index.html">
    		<img class="footer" src="doxygen.png" alt="doxygen"/>
			</a>
			1.8.12
		</li>
  </ul>
</div>
</body>
</html>

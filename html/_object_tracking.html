<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theolizer: オブジェクト追跡について</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Theolizer
   &#160;<span id="projectnumber">Version.0.4.3-Prerelease.</span>
   </div>
   <div id="projectbrief">serializer for C++ / Do you want to update your classes easily ?</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_object_tracking.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">オブジェクト追跡について </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ここでは、オブジェクト追跡について説明します。</p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="HowToObjectTracking"></a>
1.オブジェクト追跡の使い方</h1>
<h6></h6>
<p><br />
 </p>
<h2><a class="anchor" id="HowToObjectTracking11"></a>
1-1.指定方法</h2>
<p><b>・ポインタ型の指定（通常通りのシリアライズ指定です）</b></p>
<ol type="1">
<li>メンバ変数の場合は、通常通り保存指定<br />
</li>
<li>THEOLIZER_PROCESS()マクロ<br />
</li>
</ol>
<p><b>・オーナー・ポインタ型の指定（オーナー指定）</b></p>
<ol type="1">
<li>メンバ変数の場合は、THEOLIZER_ANNOTATE(FS:...&lt;...&gt;Owner)<br />
 このアノテーションはポインタに対してのみ指定できます。<br />
</li>
<li>THEOLIZER_PROCESS_OWNER()マクロ<br />
 このマクロはボインタのみ指定できます。<br />
</li>
</ol>
<p>また、回復時は初期値が必要です。nullptr、もしくは、適正なインスタンスへのポインタを設定して下さい。ポイント先インスタンスのクラスとシリアライズ・データ内のクラスが同じならば設定されていたインスタンスを維持したまま回復します。(これは保存先指定機能により複数のファイルに別々に保存されたメンバを統合するための機能です。) もし、クラスが異なる場合は解放し、シリアライズ・データと同じクラスをnewして回復します。nullptrの時も同様です。</p>
<p><b>・オブジェクト追跡指定</b></p>
<ol type="1">
<li>メンバ変数の場合は、THEOLIZER_ANNOTATE(FS:...&lt;...&gt;Pointee)</li>
<li>THEOLIZER_PROCESS_POINTEE()マクロ</li>
</ol>
<p>クラスに対してこれらの指定は不要です。（指定しても問題はありません。）</p>
<h2><a class="anchor" id="HowToObjectTracking12"></a>
1-2.サンプル・ソース</h2>
<p><b>サンプル用のクラス定義：(source/reference_and_test/version/ver1/test_object_tracking.h）</b><br />
 （静的定義領域、動的生成領域については「<a class="el" href="_object_tracking.html#HowToObjectTracking33">3-3.オブジェクト追跡で用いる用語</a> 」を参照下さい。）</p>
 <div class="fragment"><div class="line"><span class="keyword">class   </span>ObjectTrackingClass</div><div class="line">{</div><div class="line">    <span class="comment">// 静的定義領域</span></div><div class="line">    <span class="keywordtype">int</span>     mInt    THEOLIZER_ANNOTATE(FS:&lt;&gt;Pointee);</div><div class="line"></div><div class="line">    <span class="comment">// 動的生成領域</span></div><div class="line">    <span class="keywordtype">short</span>*  mShort  THEOLIZER_ANNOTATE(FS:&lt;&gt;Owner);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ObjectTrackingClass() :</div><div class="line">        mInt{0},</div><div class="line">        mShort{<span class="keyword">nullptr</span>}</div><div class="line">    { }</div><div class="line">    ObjectTrackingClass(<span class="keywordtype">int</span> iInt, <span class="keywordtype">short</span> iShort) :</div><div class="line">        mInt{iInt},</div><div class="line">        mShort{<span class="keyword">new</span> <span class="keywordtype">short</span>{iShort}}</div><div class="line">    { }</div><div class="line">    ~ObjectTrackingClass()</div><div class="line">    {</div><div class="line">        <span class="keyword">delete</span> mShort;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> check(<span class="keywordtype">int</span> iInt, <span class="keywordtype">short</span> iShort)</div><div class="line">    {</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(mInt, iInt);</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(*mShort, iShort);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">int</span>*   getStatic()  { <span class="keywordflow">return</span> &amp;mInt;  }</div><div class="line">    <span class="keywordtype">short</span>* getDynamic() { <span class="keywordflow">return</span> mShort; }</div><div class="line"></div><div class="line">    THEOLIZER_INTRUSIVE(CS, (ObjectTrackingClass), 1);</div><div class="line">};</div></div><!-- fragment --></p>
<p>ObjectTrackingClass全体はオブジェクト追跡するクラスのサンプルです。また、メンバ変数はTHEOLIZER_ANNOTATE()マクロによるオブジェクト追跡関連指定のサンプルです。<br />
</p><ul>
<li>mIntメンバ変数はオブジェクト追跡するよう指定されたメンバ変数です。</li>
<li>mShortメンバ変数はオーナー指定されたメンバ変数です。</li>
</ul>
<p><b>保存処理：(source/reference_and_test/version/ver1/test_object_tracking.cpp）</b></p>
 <div class="fragment"><div class="line">    {</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; シリアライズ対象変数定義 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(プリミティブ)</span></div><div class="line">        <span class="keywordtype">long</span>    aLong{100};</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(クラス)、動的生成領域(メンバ変数)</span></div><div class="line">        ObjectTrackingClass     aObjectTrackingClass{200, 300};</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongPtr=&amp;aLong;</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassPtr=&amp;aObjectTrackingClass;</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すオーナー・ポインタ</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongOwner=<span class="keyword">new</span> <span class="keywordtype">long</span>{101};</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassOwner=<span class="keyword">new</span> ObjectTrackingClass{201, 301};</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> temp0=makeAutoRelease(aLongOwner);                 <span class="comment">// 自動解放設定</span></div><div class="line">        <span class="keyword">auto</span> temp1=makeAutoRelease(aObjectTrackingClassOwner);  <span class="comment">// 自動解放設定</span></div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongPtr2=aLongOwner;</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassPtr2=aObjectTrackingClassOwner;</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()でオブジェクト追跡指定された静的定義領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">int</span>*                    aIntPtr=aObjectTrackingClassOwner-&gt;getStatic();</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()でオーナー指定された動的生成領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">short</span>*                  aShortPtr=aObjectTrackingClassOwner-&gt;getDynamic();</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 保存処理 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;tutorise_object_tracking.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域を指すポインタ(非オーナー)を保存</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aLongPtr);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClassPtr);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(プリミティブ)を保存</span></div><div class="line">        THEOLIZER_PROCESS_POINTEE(aSerializer, aLong);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(クラス)、動的生成領域(メンバ変数mShort)を保存</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClass);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すオーナー・ポインタを保存</span></div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aLongOwner);</div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aObjectTrackingClassOwner);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すポインタ(非オーナー)を保存</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aLongPtr2);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClassPtr2);</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()で指定したインスタンスを指すボインタ(非オーナー／オーナー)を保存</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aIntPtr);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aShortPtr);</div><div class="line"></div><div class="line">        <span class="comment">// オブジェクトIDテーブルのクリア</span></div><div class="line">        aSerializer.clearTracking();</div><div class="line">    }</div></div><!-- fragment --></p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>makeAutoRelease()</b><br />
 これはnewで獲得した領域を自動的にdeleteするためのヘルパー関数です。source/reference_and_test/version/ver1/common.hで定義しています。たいへん小さいですので、興味のある方は覗いてみて下さい。 </div><p>これにより、下図のようなデータ構造が生成され、図の順序でデータが保存されます。</p>
<div class="image">
<img src="object_tracking1.png" alt="object_tracking1.png"/>
</div>
<p><b>tutorise_object_tracking.json</b>ファイルは下記となります。 （//以下は説明のために書き込みました。） </p><pre class="fragment">{
    "SerialzierName":"JsonTheolizer",
    "GlobalVersionNo":1,
    "TypeInfoList":[1]
}
1                           // オブジェクトID=1へのポインタ(aLongPtr)
2                           // オブジェクトID=2へのポインタ(aObjectTrackingClassPtr)
[1,100]                     // オブジェクトID=1のインスタンス(aLong)
[2,{                        // オブジェクトID=2のインスタンス(aObjectTrackingClass)
    "mInt":[3,200],         // オブジェクトID=3のインスタンス(mInt)
    "mShort":[4,300]        // オブジェクトID=4のインスタンス(mShort)
}]
[5,101]                     // オブジェクトID=5のインスタンス(aLongOwner)
[6,"ObjectTrackingClass",{  // オブジェクトID=6のインスタンス(aObjectTrackingOwner)
    "mInt":[7,201],         // オブジェクトID=7のインスタンス(mInt)
    "mShort":[8,301]        // オブジェクトID=8のインスタンス(mShort)
}]
5                           // オブジェクトID=5へのポインタ(aLongPtr2)
6                           // オブジェクトID=6へのポインタ(aObjectTrackingClassPtr2)
7                           // オブジェクトID=7へのポインタ(aIntPtr)
8                           // オブジェクトID=8へのポインタ(aShortPtr)
</pre><p><b>回復処理：(source/reference_and_test/version/ver1/test_object_tracking.cpp）</b><br />
 元のデータ構造を回復できていることをチェックしています。</p>
<p><div class="fragment"><div class="line">    {</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 回復先変数定義 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(プリミティブ)</span></div><div class="line">        <span class="keywordtype">long</span>    aLong{0};</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(クラス)、動的生成領域(メンバ変数)</span></div><div class="line">        ObjectTrackingClass     aObjectTrackingClass;</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongPtr=<span class="keyword">nullptr</span>;</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassPtr=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すオーナー・ポインタ</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongOwner=<span class="keyword">nullptr</span>;</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassOwner=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> temp0=makeAutoRelease(aLongOwner);                 <span class="comment">// 自動解放設定</span></div><div class="line">        <span class="keyword">auto</span> temp1=makeAutoRelease(aObjectTrackingClassOwner);  <span class="comment">// 自動解放設定</span></div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">long</span>*                   aLongPtr2=<span class="keyword">nullptr</span>;</div><div class="line">        ObjectTrackingClass*    aObjectTrackingClassPtr2=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()でオブジェクト追跡指定された静的定義領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">int</span>*                    aIntPtr=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()でオーナー指定された動的生成領域を指すポインタ(非オーナー)</span></div><div class="line">        <span class="keywordtype">short</span>*                  aShortPtr=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 回復処理 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        std::ifstream   aStream(<span class="stringliteral">&quot;tutorise_object_tracking.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_i_serializer.html">theolizer::JsonISerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域を指すポインタ(非オーナー)を回復</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aLongPtr);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClassPtr);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(プリミティブ)を回復</span></div><div class="line">        THEOLIZER_PROCESS_POINTEE(aSerializer, aLong);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(クラス)、動的生成領域(メンバ変数mShort)を回復</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClass);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すオーナー・ポインタを回復</span></div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aLongOwner);</div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aObjectTrackingClassOwner);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すポインタ(非オーナー)を回復</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aLongPtr2);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aObjectTrackingClassPtr2);</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()で指定したインスタンスを指すボインタ(非オーナー／オーナー)を回復</span></div><div class="line">        THEOLIZER_PROCESS(aSerializer, aIntPtr);</div><div class="line">        THEOLIZER_PROCESS(aSerializer, aShortPtr);</div><div class="line"></div><div class="line">        <span class="comment">// オブジェクトIDテーブルのクリア</span></div><div class="line">        aSerializer.clearTracking();</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 結果のチェック &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域を指すポインタ(非オーナー)</span></div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aLongPtr, &amp;aLong);</div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aObjectTrackingClassPtr, &amp;aObjectTrackingClass);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(プリミティブ)</span></div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(aLong, 100);</div><div class="line"></div><div class="line">        <span class="comment">// 静的定義領域(クラス)、動的生成領域(メンバ変数)</span></div><div class="line">        aObjectTrackingClass.check(200, 300);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すオーナー・ポインタ</span></div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(*aLongOwner, 101);</div><div class="line">        aObjectTrackingClassOwner-&gt;check(201, 301);</div><div class="line"></div><div class="line">        <span class="comment">// 動的生成領域を指すポインタ(非オーナー)</span></div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aLongPtr2, aLongOwner);</div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aObjectTrackingClassPtr2, aObjectTrackingClassOwner);</div><div class="line"></div><div class="line">        <span class="comment">// THEOLIZER_ANNOTATE()で指定したインスタンスを指すボインタ(非オーナー／オーナー)</span></div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aIntPtr,   aObjectTrackingClassOwner-&gt;getStatic());</div><div class="line">        <a class="code" href="test__tool_8h.html#ace37dfcbf46e21e7b171fa2e0a7e7b1e">THEOLIZER_EQUAL_PTR</a>(aShortPtr, aObjectTrackingClassOwner-&gt;getDynamic());</div><div class="line">    }</div></div><!-- fragment --></p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="Polymorphism"></a>
2.ポリモーフィズムの使い方</h1>
<h6></h6>
<h2><a class="anchor" id="Polymorphism31"></a>
3-1.使い方</h2>
<p>ポリモーフィックな基底クラスへのポインタをオーナ・ポインタとしてシリアライズすることで、ポリモーフィックに回復されます。つまり、派生クラスのインスタンスを基底クラスへのポインタでポイントして保存して回復した場合、派生クラスのインスタンスとして回復されます。</p>
<p>そのように動作させるために、２つの注意点があります。</p>
<ol type="1">
<li>基底クラスは仮想関数を最低1つ持つ必要が有ります。<br />
 これがないと、C++の仕様上、基底クラスへのポインタが指す派生クラスのインスタンスの型を動的に判定できないためです。<br />
 <br />
</li>
<li>派生クラスはTHEOLIZER_REGISTER_CLASS()マクロで派生クラスであることを指定して下さい。<br />
 基底クラスへのポインタ経由でシリアライズしたい派生クラスは必ず指定して下さい。<br />
 指定漏れすると、シリアライズ処理する時に"Can not find the derived class for &lt;基底クラス&gt;."エラーになります。<br />
</li>
</ol>
<p>また、「<a class="el" href="_specification.html#Basic164">1-6-4.ポリモーフィズムにおける制約事項</a> 」も参照下さい。</p>
<p><b>サンプル用のクラス定義：(source/reference_and_test/version/ver1/test_polymorphism.h）</b></p>
 <div class="fragment"><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"><span class="comment">//      基底クラス</span></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>PolyBase</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>     mInt;</div><div class="line">    PolyBase(<span class="keywordtype">int</span> iInt) : mInt(iInt) { }</div><div class="line">    <span class="keyword">virtual</span> ~PolyBase() { }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> check()=0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"><span class="comment">//      派生クラス</span></div><div class="line"><span class="comment">//----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>PolyDerived0 : <span class="keyword">public</span> PolyBase</div><div class="line">{</div><div class="line">    <span class="keywordtype">short</span>   mShort;</div><div class="line">    PolyDerived0() : PolyBase(0), mShort(0) { }</div><div class="line">    PolyDerived0(<span class="keywordtype">bool</span>) : PolyBase(100), mShort(200) { }</div><div class="line">    <span class="keywordtype">void</span> check()</div><div class="line">    {</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(mInt,   100);</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(mShort, 200);</div><div class="line">    }</div><div class="line">};</div><div class="line">THEOLIZER_REGISTER_CLASS((PolyDerived0));</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PolyDerived1 : <span class="keyword">public</span> PolyBase</div><div class="line">{</div><div class="line">    std::string mString;</div><div class="line">    PolyDerived1() : PolyBase(0), mString(<span class="stringliteral">&quot;&quot;</span>) { }</div><div class="line">    PolyDerived1(<span class="keywordtype">bool</span>) : PolyBase(1000), mString(<span class="stringliteral">&quot;string&quot;</span>) { }</div><div class="line">    <span class="keywordtype">void</span> check()</div><div class="line">    {</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(mInt,    1000);</div><div class="line">        <a class="code" href="test__tool_8h.html#a18ee4fc860ce5018ecf84738dfbb6b30">THEOLIZER_EQUAL</a>(mString, <span class="stringliteral">&quot;string&quot;</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line">THEOLIZER_REGISTER_CLASS((PolyDerived1));</div></div><!-- fragment --></p>
<p><b>THEOLIZER_REGISTER_CLASS()</b>による派生クラスの指定を忘れないようにお願いします。<br />
 また、クラス名を()で囲って指定する必要が有りますのでご注意下さい。</p>
<p><b>保存処理：(source/reference_and_test/version/ver1/test_polymorphism.cpp）</b></p>
 <div class="fragment"><div class="line">    {</div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; シリアライズ対象変数定義 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        PolyBase*   aPolyBase0=<span class="keyword">new</span> PolyDerived0{<span class="keyword">true</span>};</div><div class="line">        PolyBase*   aPolyBase1=<span class="keyword">new</span> PolyDerived1{<span class="keyword">true</span>};</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 保存処理 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        std::ofstream   aStream(<span class="stringliteral">&quot;tutorise_polymorphism.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_o_serializer.html">theolizer::JsonOSerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line">        <span class="comment">// オーナーとして保存／回復する</span></div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aPolyBase0);</div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aPolyBase1);</div><div class="line"></div><div class="line">        <span class="comment">// オブジェクトIDテーブルのクリア</span></div><div class="line">        aSerializer.clearTracking();</div><div class="line">    }</div></div><!-- fragment --></p>
<p><b>回復処理：(source/reference_and_test/version/ver1/test_polymorphism.cpp）</b><br />
 元のデータ構造を回復できていることをチェックしています。</p>
<p><div class="fragment"><div class="line">    {</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 回復先変数定義 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        PolyBase*   aPolyBase0=<span class="keyword">nullptr</span>;</div><div class="line">        PolyBase*   aPolyBase1=<span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 回復処理 &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        std::ifstream   aStream(<span class="stringliteral">&quot;tutorise_polymorphism.json&quot;</span>);</div><div class="line">        <a class="code" href="classtheolizer_1_1_json_i_serializer.html">theolizer::JsonISerializer&lt;&gt;</a> aSerializer(aStream);</div><div class="line"></div><div class="line">        <span class="comment">// オーナーとして保存／回復する</span></div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aPolyBase0);</div><div class="line">        THEOLIZER_PROCESS_OWNER(aSerializer, aPolyBase1);</div><div class="line"></div><div class="line">        <span class="comment">// オブジェクトIDテーブルのクリア</span></div><div class="line">        aSerializer.clearTracking();</div><div class="line"></div><div class="line"><span class="comment">//      ---&lt;&lt;&lt; 結果のチェック &gt;&gt;&gt;---</span></div><div class="line"></div><div class="line">        aPolyBase0-&gt;check();</div><div class="line">        aPolyBase1-&gt;check();</div><div class="line">    }</div></div><!-- fragment --></p>
<p><b>tutorise_object_tracking.json</b>ファイルは下記となります。 </p><pre class="fragment">{
    "SerialzierName":"JsonTheolizer",
    "GlobalVersionNo":1,
    "TypeInfoList":[1]
}
[1,"PolyDerived0",{
    "(PolyBase)":{
        "mInt":100
    },
    "mShort":200
}]
[2,"PolyDerived1",{
    "(PolyBase)":{
        "mInt":1000
    },
    "mString":"string"
}]
</pre><p>メンバ変数名は"メンバ変数名"として記録されます。基底クラスにはメンバ変数名がないため、"(基底クラス名)"として記録しています。これにより、基底クラスの定義順序変更にも対応できます。</p>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="ClearTracking"></a>
3.オブジェクト追跡の仕組み</h1>
<h6></h6>
<h2><a class="anchor" id="HowToObjectTracking31"></a>
3-1.ポインタをシリアライズする仕組み</h2>
<p>Theolizerはboost::serializationと同様にポインタをファイルへ保存し、そのファイルを回復した時、元のポイント構造を回復できる仕組みを実装しています。</p>
<p>下記のようなオブジェクト追跡処理により実現しています。</p>
<p><b>・ポインタの保存</b><br />
</p><ol type="1">
<li>オブジェクトIDテーブル<br />
 インスタンスを保存する時に、インスタンスの先頭アドレスに対してオブジェクトIDを割り当て、インスタンスの先頭アドレスとオブジェクトIDの対応表を生成します。<br />
</li>
<li>ポインタを保存<br />
 ポインタの指すアドレスに対応するオブジェクトIDをオブジェクトIDテーブルで求め、オブジェクトIDを保存します。</li>
</ol>
<p><b>・ポインタの回復</b><br />
</p><ol type="1">
<li>オブジェクトIDテーブル<br />
 インスタンスを回復する時に、オブジェクトIDに対応するインスタンスの先頭アドレスを記録します。</li>
<li>ポインタを回復<br />
 オブジェクトIDを読み出し、それに対応するインスタンスの先頭アドレスをオブジェクトIDテーブルで求め、インスタンスの先頭アドレスをポインタに設定します。</li>
</ol>
<p>インスタンスは任意の「型」のインスタンスですが、これが構造体の場合、構造体全体の先頭アドレスと構造体の先頭メンバの先頭アドレスは一致します。（クラスの場合も同様です。）これらを纏めて１つのオブジェクトIDとすると適切に回復できないため、インスタンスの先頭アドレスだけでなく「型」も一緒に記録し、アドレスと型に対してオブジェクトIDを割り当てています。</p>
<p><br />
 </p>
<h2><a class="anchor" id="HowToObjectTracking32"></a>
3-2.オブジェクト追跡の課題</h2>
<p>ポインタを保存する前に必ずそのポインタが指すインスタンスを保存できれば特に問題はないのですが、そうとは限りません。<br />
</p>
<p>ポインタの指すインスタンスが例えばローカル変数で、それがポインタより後でシリアライズ指示される場合もあります。<br />
 そのようなデータ構造を回復するためには、そのローカル変数の保存は最初にポインタをシリアライズ指示された時ではなく、ローカル変数のシリアライズ指示まで遅らせるべきです。そうしないと順序よく回復できないため回復手順が複雑で負荷が高いものになります。<br />
</p>
<p>しかし、ポインタが指している領域の所有権を当該ポインタが持っている場合は、最初にポインタをシリアライズ指示された時にインスタンスを保存すればOKです。最初にポインタを回復する際にインスタンス領域を確保して回復すれば適切にポイント構造を回復できますから。(*1)<br />
</p>
<p>従って、ポインタがポイント先の所有権を持っているかどうかを判定できれば適切に保存／回復できるのですが、残念ながらシリアライズしようとしているポインタが所有権のある領域を指しているのか、そうでない領域を指しているのか判定する仕組みはC++言語仕様にはありません。</p>
<p>そこで、下記２つの選択肢を検討しました。</p>
<ol type="1">
<li>boost::serializationのようにこのようなケースをエラーとする(*2)<br />
 この場合ローカル変数のようなインスタンスはそれをポイントするポインタより先に保存する必要が有ります。できれば避けたい制約と思います。</li>
<li>ポインタの属性として所有権の有無をプログラマが指定する 保存順序の制約はなく、処理負荷も特に高くはなりません。その代わりプログラマに少し負担がかかります。<br />
</li>
</ol>
<p>さて、インスタンスの所有権を持つか持たないかをポインタの属性とすることはリソース・リークし難いプログラムになりますのでたいへん好ましいと考えます。実際、C++11のスマート・ポインタは正にそのような概念に基づいています。スマート・ポインタが管理する領域はスマート・ポインタが所有権を持ち、その他のポインタは所有権を持ちません。所有権が明確ですのでメモリ・リークのリスクを大きく低減できます。<br />
</p>
<p>そこで、インスタンスの所有権の有無をポインタの属性とする仕組みを実装することで、この問題を回避することにしました。<br />
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*1)ポインタが指すオブジェクトをオブジェクト追跡単位の最後で保存する案も検討しました<br />
 途中でボイントされているローカル変数がシリアライズされたら、その時点で保存すれば良いです。制約も少なくプログラマへの負荷も小さいように見えます。<br />
 しかし、最後までポイント先のインスタンスがシリアライズされなかった時、ユーザ・プログラムにおけるシリアライズ漏れ不具合なのか、所有権のある領域なのかの判断がつきません。前者の不具合は発見が遅れるとかなり痛いですので、この案は棄却しました。 </div><div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*2)boostの場合<br />
 boost::serializationはこのような使い方を許可していません。上記ケースではローカル変数を保存する時にpointer_conflict例外が投げられます。<br />
 <a href="http://www.bnikolic.co.uk/blog/cpp-boost-ser-conflict.html">"Pointer Conflict" Errors in the Boost Serialization Library</a><br />
 <a href="http://stackoverflow.com/questions/37747596/boost-serialization-with-pointers">Boost serialization with pointers</a> </div><p><br />
 </p>
<h2><a class="anchor" id="HowToObjectTracking33"></a>
3-3.オブジェクト追跡で用いる用語</h2>
<p>このために、少し用語を定義しました。</p>
<ol type="1">
<li>静的定義領域<br />
 ポインタが所有権（獲得／解放する権限）を持つことができない領域です。下記があります。<ul>
<li>グローバル変数</li>
<li>ローカル変数</li>
<li>他のクラスのメンバ変数(非ボインタ) これは、例えばstruct Foo { int mInt; };のmIntです。ポインタ側からmIntを獲得／解放することができません。</li>
</ul>
</li>
<li>動的生成領域(*3)<br />
 newやnew[]で獲得するインスタンスです。</li>
<li>ポインタ型<br />
 通常のポインタです。これはポイント先のインスタンスの所有権を持ちません。<br />
 静的定義領域、動的生成領域の両方をボイントすることができませ。<br />
</li>
<li>オーナー・ポインタ型<br />
 ポイント先のインスタンスの所有権を持っているポインタです。<br />
 当然ですが動的生成領域のみポイント可能です。<br />
</li>
</ol>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*3)「静的定義領域」と言う名称<br />
 以前、teratailで「<a href="https://teratail.com/questions/20206">インスタンス生成方法の呼び方について</a>」質問し、catsforepawさんの回答を元に決定しました。<br />
 遠いところからですが、catsforepawさん、その節はありがとうございました。 </div><p><br />
 </p>
<h2><a class="anchor" id="HowToObjectTracking34"></a>
3-4.オブジェクト追跡対象について</h2>
<p>静的定義領域は、全てのシリアライズ対象の変数がオブジェクト追跡候補になります。しかし、実際にポインタでポイントされる変数はその内の一部だけですので、全てをオブジェクト追跡するのは無駄が多いです。そこで、「<a class="el" href="_specification.html#Basic21">2-1.オブジェクト追跡する領域について</a> 」で示した方法でオブジェクト追跡対象を絞り込んでいます。</p>
<p><br />
 </p>
<h2><a class="anchor" id="HowToObjectTracking35"></a>
3-5.オブジェクト追跡単位について</h2>
<p>「<a class="el" href="_specification.html#Basic22">2-2.オブジェクト追跡単位について</a> 」に示したオブジェクト追跡単位について少し詳しく説明します。</p>
<p>これはオブジェクトIDテーブルの有効期間です。clearTracking()することで</p>
<ol type="1">
<li>オブジェクトIDテーブルにシリアライズされていないインスタンスが登録されていないか確認します</li>
<li>オブジェクトIDテーブルをクリアします</li>
</ol>
<p>前者により、ユーザ・プログラムのバグ検出をサポートします。<br />
 後者により、不要なオブジェクト追跡を解除できるのでバフォーマンスを改善できます。<br />
</p>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> <b>注意事項：</b><br />
 解放したインスタンスを追跡したままにしていると未定義メモリ・アクセスが発生する場合があります。ですので、clearTracking()するまで、もしくは、シリアライザ自身を破棄するまで下記インスタンスを破棄しないで下さい。<br />
 ・シリアライズしたインスタンス<br />
 ・シリアライズしたポインタが指すインスタンス<br />
 なお、clearTracking()することで「シリアライズした」と言う記録が全て破棄されますので、必要であれば、cleartTracking()後、最初のシリアライズまでの間ならばインスタンスを安全に破棄できます。 </div><p><br />
 </p><h6></h6>
<h1><a class="anchor" id="TestObjectTracking"></a>
4.オブジェクト追跡の網羅的な使用例（自動テスト）の説明</h1>
<h6></h6>
<h2><a class="anchor" id="TestObjectTracking41"></a>
4-1.各種メモリへのポインタのテスト</h2>
<h3><a class="anchor" id="TestObjectTracking411"></a>
4-1-1.概要</h3>
<p>ここでは、C++で用いられる少し異なるメモリ上のインスタンスへのポインタが適切に回復されることをテストしています。具体的には下記の通りです。</p>
<ol type="1">
<li>グローバル変数<br />
 ここには静的定義領域のみ存在できますので、ここへのポインタをオーナー指定できません。<br />
</li>
<li>ローカル変数（スタック変数）<br />
 ここも静的定義領域のみ存在できますので、ここへのポインタをオーナー指定できません。<br />
</li>
<li>ヒープ変数<br />
 ここには動的生成領域と静的定義領域の両方が存在できます。newで獲得したクラスのインスタンス全体は動的生成領域です。そのクラスの各メンバ変数は静的定義領域となります。基底クラスは少し複雑です。<br />
<ul>
<li>ポリモーフィックな（仮想関数がある）クラスの場合<br />
 基底クラスへのポインタ経由でdeleteできますので、基底クラスへのポインタをオーナー指定できます。<br />
 <br />
</li>
<li>非ポリモーフィックな（仮想関数がない）クラスの場合<br />
 C++仕様上、基底クラスへのポインタ経由でdeleteすると派生クラスのデストラクタは呼ばれず基底クラスとしてデストラクトされます。従って、非ポリモーフィックなクラスの場合、その基底クラスへのポインタをオーナー指定してはいけません。<br />
</li>
</ul>
</li>
</ol>
<p>下記組み合わせのインスタンスとポインタ（非オーナー）について保存／回復テストを行います。<br />
 </p><pre class="fragment">静的定義領域(グローバル変数, ローカル変数, メンバ変数)　＋　動的生成領域(プリミティブ, クラス)
                            ×
Pointee指定プリミティブ型(long)　＋　Pointee指定なしクラス型（ObjectTracking0）　＋　Pointee指定クラス型（ObjectTracking1）
</pre><p>また、2番目以降の基底クラス・ポインタは一般にインスタンス先頭ではないアドレスを指しますが、このケースにも対応できていることを確認します。 そのために、派生クラスのインスタンス、および、その２番目の基底クラスへのポインタをシリアライズし、ポインタが回復したインスンタスをポイントすることを確認しています。</p>
<p>更に、動的生成領域(クラス)へのポインタ(非オーナー)のテストを実施する際に、std::shared_ptr&lt;&gt;を非侵入型手動対応しました。その時、<a href="https://github.com/yossi-tahara/Theolizer/issues/18">std::shared_ptr&lt;&gt;対応は意外に難しい</a>ことが分かり、いくつか複雑な対応を行いましたので、ここでその一部のテストも行っています。(後日、標準コンテナ対応する予定です。その時、網羅的な自動テストを実装します。)</p>
<h3><a class="anchor" id="TestObjectTracking412"></a>
4-1-2.ソース・コード</h3>
<p><b>source/reference_and_test/version/ver1/test_object_tracking.h</b>でテスト用のクラスを定義してます。<br />
</p>
<ol type="1">
<li>２番目以降の基底クラスへのポインタの回復テスト用<ul>
<li>ObjectTrackingBase0 １番目の基底クラス</li>
<li>ObjectTrackingBase1 ２番目の基底クラス</li>
<li>ObjectTrackingDerived 上記２つを継承したクラス<br />
 <br />
</li>
</ul>
</li>
<li>各種メモリへのポインタのテスト用<ul>
<li>ObjectTracking0 被ポイント指定(Pointee)なし</li>
<li>ObjectTracking1 被ポイント指定(Pointee)あり</li>
<li>StaticDefinition メンバ変数静的定義領域用</li>
<li>Pointers 自動シリアライズするポインタの定義<br />
 <br />
</li>
</ul>
</li>
</ol>
<p><b>source/reference_and_test/version/ver1/test_object_tracking2.cpp</b>でテスト関数を定義してます。<br />
</p>
<ol type="1">
<li>保存処理<br />
 template&lt;class tSerializer&gt;<br />
 void saveObjectTracking(tSerializer&amp; iSerializer)の前半<br />
 <br />
</li>
<li>回復処理<br />
 template&lt;class tSerializer&gt;<br />
 void loadObjectTracking(tSerializer&amp; iSerializer)の前半<br />
</li>
</ol>
<h2><a class="anchor" id="TestObjectTracking42"></a>
4-2.ポインタ(非オーナー)のテスト</h2>
<h3><a class="anchor" id="TestObjectTracking421"></a>
4-2-1.概要</h3>
<p>ポインタのシリアライズ、および、ポイント先のインスタンスのシリアライズについて、指定方法が手動(トップ・レベル)、自動シリアライズ（自動型のメンバ変数）、手動(非トップ・レベル)の３種類あります。それぞれについて各種の型、および、ポインタ→インスタンスとインスタンス→ポインタの順序おのおのの組み合わせのテストを行います。 </p><pre class="fragment">ポインタ：
　手動(トップ・レベル)　＋　自動シリアライズ（自動型のメンバ変数）　＋　手動(非トップ・レベル)
            ×
インスタンス：
　手動(トップ・レベル)　＋　自動シリアライズ（自動型のメンバ変数）　＋　手動(非トップ・レベル)
            ×
全てのプリミティブ　＋　enum型　＋　scoped num型　＋　クラス　＋　各配列型
            ×
ポインタを先に保存　＋　インスタンスを先に保存
</pre><h3><a class="anchor" id="TestObjectTracking422"></a>
4-2-2.ソース・コード</h3>
<p><b>source/reference_and_test/version/ver1/test_object_tracking.h</b>でテスト用のクラスとマクロを定義してます。<br />
</p>
<ol type="1">
<li>DEFINE_MEMBERS()マクロ<br />
 各種の型に対応する、変数宣言や初期化を定義するためのマクロです。「<a class="el" href="_class_variation.html#SingleTest">5-1.単独テスト</a> 」と同じ名前ですが、少し異なるマクロです。定義している変数の型は同じですが、初期化値が異なります。<br />
 <br />
</li>
<li>PointeeListクラス<br />
 静的定義領域の定義です。各型のインスタンスについて、自動シリアライズと手動(トップ・レベル)を担います。前者は非侵入型完全自動として処理し、後者はsavePointee()とloadPointee()関数で行います。<br />
 <br />
</li>
<li>PointeeListManualクラス<br />
 静的定義領域の定義です。各型のインスタンスについて、手動(非トップ・レベル)を担います。<br />
 <br />
</li>
<li>PointerListクラス<br />
 ポインタ(非オーナー)の定義です。各型のポインタについて、自動シリアライズと手動(トップ・レベル)を担います。前者は非侵入型完全自動として処理し、後者はsavePointer()とloadPointer()関数で行います。トップ・レベル、および、自動型については、例えばデバッグやログ用にconst領域へのポインタの保存を想定して、constポインタも定義しています。<br />
 <br />
</li>
<li>PointerListManual<br />
 ポインタ(非オーナー)の定義です。各型のポインタについて、手動(非トップ・レベル)を担います。回復処理を行わない手動型の実装は想定不要と考えますので、constポインタを定義していません。<br />
 <br />
</li>
</ol>
<p><b>source/reference_and_test/version/ver1/test_object_tracking2.cpp</b>でテスト関数を定義してます。<br />
</p>
<ol type="1">
<li>保存処理<br />
 template&lt;class tSerializer&gt;<br />
 void saveObjectTracking(tSerializer&amp; iSerializer)の後半<br />
 <br />
</li>
<li>回復処理<br />
 template&lt;class tSerializer&gt;<br />
 void loadObjectTracking(tSerializer&amp; iSerializer)の後半<br />
</li>
</ol>
<h2><a class="anchor" id="TestObjectTracking43"></a>
4-3.オーナー・ポインタのテスト</h2>
<h3><a class="anchor" id="TestObjectTracking431"></a>
4-3-1.概要</h3>
<p>オーナー・ポインタのシリアライズについて、指定方法が手動(トップ・レベル)、自動シリアライズ（自動型のメンバ変数）、手動(非トップ・レベル)の３種類あります。それぞれについて各種の型の組み合わせのテストを行います。また、nullptrの回復もテストします。<br />
 （ポインタ(非オーナー)と異なり、インスタンス側はポインタが管理するため組み合わせが発生しません。また、インスタンスの保存は先に出現した方が先ですので、保存順序の組み合わせも発生しません。） </p><pre class="fragment">オーナー・ポインタ：
　手動(トップ・レベル)　＋　自動シリアライズ（自動型のメンバ変数）　＋　手動(非トップ・レベル)
            ×
全てのプリミティブ　＋　enum型　＋　scoped num型　＋　クラス　＋　各配列型
</pre><h3><a class="anchor" id="TestObjectTracking432"></a>
4-3-2.ソース・コード</h3>
<p><b>source/reference_and_test/version/ver1/test_object_tracking.h</b>でテスト用のクラスとマクロを定義してます。<br />
</p>
<ol type="1">
<li>DEFINE_MEMBERS()マクロ<br />
 ポインタ(非オーナー)と共通です。<br />
 <br />
</li>
<li>NEW_ARRAY()マクロ<br />
 C++は、配列型(Type[N])をnewした結果は残念なことに配列型へのポインタ(Type(*)[N])にならず要素へのポインタ(Type*)になります。そのため、配列型へのポインタ(Type(*)[N])変数へそのままでは代入できません。これをreinterpret_cast&lt;Type(*)[N]&gt;()して(*4)代入できるようにするマクロです。<br />
 <br />
</li>
<li>OwnerListクラス<br />
 オーナー・ポインタの定義です。各型のポインタについて、自動シリアライズと手動(トップ・レベル)を担います。前者は非侵入型完全自動として処理し、後者はsavePointer()とloadPointer()関数で行います。インスタンスを回復しないオーナー指定ポインタは意味がないので、constポインタは定義していません。<br />
 <br />
</li>
<li>OwnerListManualクラス<br />
 オーナー・ポインタの定義です。各型のポインタについて、手動(非トップ・レベル)を担います。OwnerListクラスと同様constポインタを定義していません。<br />
 <br />
</li>
</ol>
<div style="padding: 10px; margin-bottom: 10px; border: 1px solid #333333; border-radius: 10px; background-color: #d0d0d0;"> (*4)「配列型へのポインタ」のサポート<br />
 以前、teratailで「<a href="https://teratail.com/questions/34266">配列型(サイズ含む)へのポインタをnewで生成したい</a>」旨を質問してraccyさんの回答をヒントに対応できました。<br />
 遠いところからですが、raccyさん、ありがとうございました。 </div><p><b>source/reference_and_test/version/ver1/test_object_tracking3.cpp</b>でテスト関数を定義してます。<br />
</p>
<ol type="1">
<li>保存処理<br />
 template&lt;class tSerializer&gt;<br />
 void saveObjectTracking3(tSerializer&amp; iSerializer)<br />
 <br />
</li>
<li>回復処理<br />
 template&lt;class tSerializer&gt;<br />
 void loadObjectTracking3(tSerializer&amp; iSerializer)<br />
</li>
</ol>
<p><br />
 </p><h6></h6>
<h1><a class="anchor" id="TestPolymorphism"></a>
5.ポリモーフィズムの網羅的な使用例（自動テスト）の説明</h1>
<h6></h6>
<p>ここでは、基底クラスへのポインタでポイントされる異なる派生クラスを適切に回復できることを確認します。<br />
 非侵入型完全自動、侵入型半自動、非侵入型手動の３種類の基底クラスと派生クラスを用意し、派生クラスは３種類の基底クラスを全て継承しました。</p>
<p><b>source/reference_and_test/version/ver1/test_polymorphism.h</b>でテスト用のクラスを定義してます。<br />
</p>
<ol type="1">
<li>基底クラス<ul>
<li>PolyBaseFullAuto 非侵入型完全自動</li>
<li>PolyBaseHalfAuto 侵入型半自動</li>
<li>PolyBaseManual 非侵入型手動<br />
 <br />
</li>
</ul>
</li>
<li>派生クラス<ul>
<li>PolyDerivedFullAuto 非侵入型完全自動</li>
<li>PolyDerivedHalfAuto 侵入型半自動</li>
<li>PolyDerivedManual 非侵入型手動</li>
</ul>
</li>
</ol>
<p><b>source/reference_and_test/version/ver1/test_polymorphism.cpp</b>でテスト関数を定義してます。<br />
</p>
<ol type="1">
<li>保存処理<br />
 template&lt;class tSerializer&gt;<br />
 void savePolymorphism(tSerializer&amp; iSerializer)<br />
 <br />
</li>
<li>回復処理<br />
 template&lt;class tSerializer&gt;<br />
 void loadPolymorphism(tSerializer&amp; iSerializer)<br />
</li>
</ol>
<p>基底クラスのインスタンスをstd::unique_ptr&lt;&gt;で保持し、そのstd::unique_ptr&lt;&gt;のリストをstd::vector&lt;&gt;で保持しています。（std::vector&lt;&gt;とstd::unique_ptr&lt;&gt;を非侵入型手動クラスとして仮にシリアライズ対応しています。）<br />
 ３種類の基底クラス毎にstd::vector&lt;&gt;を用意しているので、std::vector&lt;&gt;も下記の３種類あります。</p>
<ul>
<li>非侵入型完全自動</li>
<li>侵入型半自動</li>
<li>非侵入型手動</li>
</ul>
<p>各std::vector&lt;&gt;には３種類の派生クラスのインスタンスを登録して、std::vector&lt;&gt;を保存します。そして、全てのポインタをnullptr設定して回復し、保存した時の派生クラスを回復できたことを確認しています。<br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">--目次--</a></li><li class="navelem"><a class="el" href="_usage_individual.html">使用方法（個別）</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
